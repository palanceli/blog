---
layout: post
title: Obj-C总结
date: 2017-03-13 23:00:00 +0800
categories: 随笔笔记
tags: obj-c
toc: true
comments: true
---
对于不是很高频使用，但时不时要接触的知识，最重要的是建立起它的概念体系，描绘出大象的轮廓。遇到问题首先知道它是大象腿还是大象鼻子，如果需要更深入了解，能很快找到相关的手册。本文希望能给自己起到这样的作用。<!-- more -->

# 类的声明、定义和使用
## 示例
``` obj-c
// XYZPerson.h
@interface XYZPerson : NSObject // 指定继承关系
@property NSString *firstName;  // 声明属性
@property NSString *secondName;

// 声明类方法
+(XYZPerson*)createInstanceWithFirstName:(NSString*)firstName secondName:(NSString*)secondName;
// 声明实例方法
-(void)sayHello;
@end
```

``` obj-c
// XYZPerson.m
#import "XYZPerson.h"

@implementation XYZPerson
// 实现类方法
+(XYZPerson*)createInstanceWithFirstName:(NSString *)firstName secondName:(NSString *)secondName

{
  XYZPerson * obj = [[XYZPerson alloc]init];  // 构造对象
  obj.firstName = firstName;    // 存取属性值
  obj.secondName = secondName;
  return obj;
}

// 实现实例的私有方法
-(void)say:(NSString*) content
{
  NSLog(@"%@", content);
}

// 实现实例方法
-(void)sayHello
{
  NSString* content = [NSString stringWithFormat:@"Hello %@ %@", self.firstName, self.secondName];
  [self say:content];
}
@end
```
``` obj-c
// main.m
#import "XYZPerson.h"

int main(int argc, const char * argv[]) {
  @autoreleasepool {
    XYZPerson* person = [XYZPerson createInstanceWithFirstName:@"Palance" secondName:@"Li"];
    [person sayHello];
  }
  return 0;
}
```
## 类
类的定义格式为：
``` obj-c
@interface <ClassName> : <BaseClassName>
// 数据、函数定义
@end
```
即使在不同的类库和框架中，类名字也必须是唯一的，因此通常在类名前加上三到四个你的前缀。
## 成员属性
写在interface中的属性相当于该类的成员变量，可以供类内外访问。Obj-C的数据类型分两种：Object-C对象和简单数据类型。前者是从NSObject继承的抽象数据类型，后者包括int、float、char等。所有Object-C对象都是通过指针提领，所以声明的时候都带`*`号。

成员属性的定义格式为：
``` obj-c
@property (属性修饰符) <DataType> <PropertyName>
```
编译器会按如下规则自动为之生成存取方法：
* getter方法，方法名和<PropertyName>一样
* setter方法，以`set`开头，跟上首字母大写的属性名

如：
``` obj-c
@interface XYZPerson : NSObject
@property NSString *firstName;
...
@end
// 生成的存取方法为：
-(void)setFirstName:(NSString*)firstName;
-(NSString*)firstName;
```
同时支持点语法来访问该成员属性：
``` obj-c
XYZPerson* person = [XYZPerson createInstanceWithFirstName:@"Palance" secondName:@"Li"];

person.firstName = @"Jack";             // 等价于
[person setFirstName:@"Jack"];

NSString* firstName = person.firstName; // 等价于
NSString* firstName = [person firstName];
```

## 属性修饰符
通过属性修饰符可以指定属性的特征：
``` obj-c
@property (readonly) NSString *firstName; // 禁止为之生成setter方法
@property (readonly, getter=isMale) NSString *male; // 指定getter方法名为isMale
```
``` obj-c
@property (atomic) NSObject *explicitAtomicObject;  // 指定为原子性
@property (nonatomic) NSObject *nonatomicObject;    // 指定为非原子性
```
指定原子性表明，当被不同的线程同时调用，存取器（存取方法）保证永远是完整地通过getter方法取回或完整地通过setter方法设置一个值。
属性原子性不等价于对象的线程安全性。比如在一个线程上通过原子性的存取器修改了一个XYZPerson的姓名；另一个线程访问了姓名。原子性的getter方法会返回完整的字符串（不会崩溃），但是并不能保证姓和名是对应的。如果名字是在修改之前获取，而姓是在修改之后获取，此时得到的姓名就不是对应的。
``` obj-c
@property (weak) id weakObj;        // 声明weakObj为弱引用
@property (strong) id strongObj;    // 声明strongObj为强引用，默认为strong
```
`strong`和`weak`关键字也适用于一般的变量：
``` obj-c
NSDate *originalDate = self.lastModificationDate;
self.lastModificationDate = [NSDate date];
NSLog(@"Last modification date changed from %@ to %@",
                        originalDate, self.lastModificationDate);
```
本例中，局部变量originalData强引用了lastModificationDate对象。当lastModificationDate不再强引用原始的日期数据，原始的日期数据不会被释放，因为它被originalData强引用了。
``` obj-c
NSDate * __weak originalDate = self.lastModificationDate;
self.lastModificationDate = [NSDate date];
```
这个originalDate变量有指向nil的可能：当self.lastModificationDate被重新赋值，也就不再强引用原来的日期数据了，如果没有其他的强引用施加于其上，原始的日期数据就会被释放而originalDate设置成nil。
在使用一个弱引用属性前想要知道它是不是nil，仅仅在用之前测试它是不够的：
``` obj-c
if (self.someWeakProperty) {
    [someObject doSomethingImportantWith:self.someWeakProperty];
}
```
因为在多线程应用中，可能会在测试和调用的中间被释放，导致这个测试失效。应该声明一个强引用局部变量来缓存这个值，像这样：
``` obj-c
NSObject *cachedObject = self.someWeakProperty;           // 1
if (cachedObject) {                                       // 2
    [someObject doSomethingImportantWith:cachedObject];   // 3
}                                                         // 4
cachedObject = nil;                                       // 5
```

## 属性的背后
默认情况下，编译器会为一个可读写（readwrite）的属性生成一个实例变量，该变量名是在属性名前面加一个下划线。在前面的例子中，如下三种方法是等价的：
``` obj-c
-(void)sayHello
{
  NSString* content = [NSString stringWithFormat:@"Hello %@ %@",
                       self.firstName, self.secondName];
  // 等价于
  content = [NSString stringWithFormat:@"Hello %@ %@",
             [self firstName], [self secondName]];
  // 等价于
  content = [NSString stringWithFormat:@"Hello %@ %@",
             _firstName, _secondName];
  [self say:content];
}
```
可以指定该实例变量的名字：
``` obj-c
@implementation XYZPerson
@synthesize secondName = surName; // secondName为属性名，surName为实例变量名
...
@end
```
此时属性名依然是`secondName`，通过`[self secondName]`或`self.secondName`来访问该属性，只是它对应的实例变量名不再是`_secondName`而是`surName`。

可以使用`@synthesize`而不指定变量名：
``` obj-c
@implementation XYZPerson
@synthesize secondName; // 属性名和实例变量名均为`secondName`
...
@end
```

如果仅定义实例变量，而不定义属性，可以这么写：
``` obj-c
@interface SomeClass : NSObject {
    NSString *_myNonPropertyInstanceVariable;
}
...
@end

@implementation SomeClass {
    NSString *_anotherCustomInstanceVariable;
}
...
@end
```

**不是每个属性都需要对应一个实例变量。**例如：
``` obj-c
@interface XYZPerson : NSObject // 指定继承关系
@property NSString *firstName;
@property NSString *secondName;
@property NSString *fullName;  // 不需要对应实例变量
...
@end
```
`fullName`是通过`firstName`和`secondName`合成的，因此没有必要再为它保留一个实例变量，只需要每次访问该属性时合成字符串即可：
``` obj-c
@implementation XYZPerson
- (NSString *)fullName {
    return [NSString stringWithFormat:@"%@ %@", self.firstName, self.secondName];
}
@end
```

可以自己实现属性的存取方法，在存取方法里面应直接访问实例变量，同时检查实例变量是否已经存在并完成初始化：
``` obj-c
- (XYZObject *)someImportantObject {
    if (!_someImportantObject) {
        _someImportantObject = [[XYZObject alloc] init];
    }
 
    return _someImportantObject;
}
```
> 注意：当编译器自动生成了至少一个存取方法时，它便会自动帮你生成一个实例变量。如果你为readwrite属性实现了getter和setter或为readonly属性实现了getter，编译器就假定你希望完全控制这个属性的实现，便不会自动帮你生成实例变量了。 如果你依然需要一个实例变量，你需要显式申请合成一个： @Synthesize property = _property

## 在初始化方法中直接访问实例变量名
在初始化方法中，应该直接访问实例变量，因为在这个时候，属性可能还未被完全初始化。应该像这样来实现初始化方法：
``` obj-c
- (id)initWithFirstName:(NSString *)aFirstName lastName:(NSString *)aLastName {
    self = [super init];

    if (self) {
        _firstName = aFirstName;
        _lastName = aLastName;
    }

    return self;
}
```
## 成员方法
在`@interface`中声明的方法都是公有方法，以`+`号打头的表示类方法，以`-`号打头的表示实例方法。在`@implementation`中定义而未在`@interface`中声明的方法，是该类的私有方法，相当于类的静态函数。

方法的声明的格式为：
`- (void)someMethodWithFirstValue:(Type1)value1 secondValue:(Type2)value2;`
每个参数都以`:`号打头，之后括号内是参数类型，之后是参数名，参数之间用空格隔开，该函数的函数名为`someMethodWithFirstValue:secondValue:`。

## 调用方法
在obj-c中，调用对象的成员方法又称为向对象发送消息，格式为：
`[<对象> <方法>:<参数>];`
如果向自己发消息，格式为：`[self <方法>:<参数>];`
如果向基类发消息，格式为：`[super <方法>:<参数>];`
如果参数是obj-c对象，需要传入对象指针。

由于obj-c是一种动态语言，下面的代码不会被编译器报错，但会在运行时产生异常，因为NSString并没有`removeAllObjects`方法：
``` obj-c
id someObject = @"Hello, World!";
[someObject removeAllObjects];
```
如果这么写，编译器就会报错了：
``` obj-c
NSString *someObject = @"Hello, World!";
[someObject removeAllObjects];
```
## 创建obj-c对象
所有的obj-c对象都是动态创建的，NSObject类提供了申请内存和初始化的方法：
`+ (id)alloc`申请内存
`- (id)init` 初始化
`id`是obj-c中特殊的关键字，等价于`(NSObject*)`
通常创建对象写作：
`NSObject *newObject = [[NSObject alloc] init];`

对于常量，还有一种更简洁的语法：
``` obj-c
NSString *someString = @"Hello, World!";
// 它等价于：
NSString *someString = [NSString stringWithCString:"Hello, World!"
                                              encoding:NSUTF8StringEncoding];
```
类似的还可以定义：
``` obj-c
NSNumber *myBOOL = @YES;
NSNumber *myFloat = @3.14f;
NSNumber *myInt = @42;
NSNumber *myLong = @42L;
NSArray *myArray = @[0, 1, 2, 3];
```

## 对象的比较
对于obj-c对象，
``` obj-c
if (firstPerson == secondPerson) {
   // firstPerson和secondPerson是否指向同一个对象
}
...
if ([firstPerson isEqual:secondPerson]) {
   // firstPerson和secondPerson的数据是否相等
}
```

## 空指针nil
可以用如下方式判断指针是否为空或非空：
``` obj-c
if (somePerson != nil) {
   // somePerson 指针非空
}
...
if (somePerson) {
   // somePerson 指针非空
}
...
if (!somePerson) {
   // somePerson 指针为空
}
```
向nil发送消息不会发生编译和运行时错误，但这么做什么都不会发生。