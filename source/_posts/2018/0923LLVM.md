---
layout: post
title: LLVM
date: 2018-09-23 14:00:00 +0800
categories: 技术随笔
tags: 随笔
toc: true
comments: true
---

![](0923LLVM/img01.jpeg)  
本文是对[LLVM官网入门教程](http://llvm.org/docs/tutorial/index.html)中《Kaleidoscope:Implementing a Language with LLVM》和《Building a JIT in LLVM》的总结。主要目的是了解LLVM的能力边界。

<!-- more -->
# 整体架构
这张图对于了解LLVM的整体架构非常重要：  
![](0923LLVM/img02.png)  
图很清晰，不需过多解释。  
在[《Kaleidoscope:Implementing a Language with LLVM》](http://llvm.org/docs/tutorial/index.html)这篇文章也是按照这个脉络介绍的：  
![](0923LLVM/img03.png)  

# Kaleidoscope: Implementing a Language with LLVM
[词法分析器](/2018/06/18/2018/0618BuildASimpleInterpreter1/#%E8%AF%8D%E6%B3%95%E5%88%86%E6%9E%90%E5%99%A8)和[语法分析器](/2018/06/18/2018/0618BuildASimpleInterpreter1/#%E8%AF%AD%E6%B3%95%E5%88%86%E6%9E%90%E5%99%A8)的概念在[编写编译器和解释器一](/2018/06/18/2018/0618BuildASimpleInterpreter1/)已经介绍过了，熟悉这些概念后，在教程里稍微看下实现即可。词法分析的逻辑比较简单，每次吐出一个token，我们直接进入Chapter02的语法分析。

## 语法分析
语法分析的结果是AST，[Chapter02](http://llvm.org/docs/tutorial/LangImpl02.html)为AST定义的数据结构为：
![](0923LLVM/img04.png)  
我没想明白<font color=red>为什么函数原型和函数不算做表达式，不从ExprAST派生呢？</font>

代码主路径展开就是这样：
![](0923LLVM/img05.png)  

## 代码生成
[Chapter03](http://llvm.org/docs/tutorial/OCamlLangImpl3.html)的代码生成没有太多编译原理相关的概念，更多是怎么运用`LLVM::Builder`生成指令的技术细节问题。首先在每个`HandleXXX(...)`函数中完成了AST的构建之后，将调用此次AST根部节点的`codegen()`函数来生成代码，由于AST节点是可以循环引用的，因此父节点再调用子节点的`codegen()`完成整棵树枝的代码生成：
``` objc
static void HandleDefinition() {
  if (auto FnAST = ParseDefinition()) {
    if (auto *FnIR = FnAST->codegen()) {
      ……
      FnIR->print(errs());
    }
  } else 
  ……
}
```
剩下就是为每个AST节点定义`codegen()`函数了：
![](0923LLVM/img06.png)  
![](0923LLVM/img07.png)  

## 优化器支持和JIT
[Chapter04](http://llvm.org/docs/tutorial/LangImpl04.html)短期我学习LLVM的目标是了解它的能力边界，我想基于它来实现iOS的热更新。优化属于更进一步的实现环节，因此很简略地跳过了，只要知道优化是通过FPM(Function Pass Manager)实现的，每个优化器是一个Pass实例，需要做什么优化只需要将对应的Pass实例添加到FPM即可：
``` objc
static void InitializeModuleAndPassManager() {
  // 获得TheModule并为之绑定FPM
  TheModule = llvm::make_unique<Module>("my cool jit", TheContext);
  // 这一句属于JIT的初始化
  TheModule->setDataLayout(TheJIT->getTargetMachine().createDataLayout());

  // Create a new pass manager attached to it.
  TheFPM = llvm::make_unique<legacy::FunctionPassManager>(TheModule.get());

  // 通过一系列add设置优化策略
  //Do simple "peephole" optimizations and bit-twiddling optzns.
  TheFPM->add(createInstructionCombiningPass());
  // Reassociate expressions.
  TheFPM->add(createReassociatePass());
  // Eliminate Common SubExpressions.
  TheFPM->add(createGVNPass());
  // Simplify the control flow graph (deleting unreachable blocks, etc).
  TheFPM->add(createCFGSimplificationPass());

  TheFPM->doInitialization();
}
```

JIT是用来解释执行前面`codegen()`生成的LLVM IR代码，这是我比较关心的环节。在本教程中仅展示了JIT的使用，没有太深入到其实现。首先是初始化：
``` objc
int main() {
  // 为创建JIT初始化环境 
  InitializeNativeTarget();
  InitializeNativeTargetAsmPrinter();
  InitializeNativeTargetAsmParser();

  ……
  getNextToken();
  // 创建TheJIT
  TheJIT = llvm::make_unique<KaleidoscopeJIT>();

  InitializeModuleAndPassManager();

  // Run the main "interpreter loop" now.
  MainLoop();

  return 0;
}
```
都是些程式化的调用，需要注意TheJIT其实是自定义的`KaleidoscopeJIT`实例，而不直接来自LLVM API，想要了解细节应该深入到该类的内部，这是[《Building a JIT in LLVM》](http://llvm.org/docs/tutorial/index.html)中讨论的问题。