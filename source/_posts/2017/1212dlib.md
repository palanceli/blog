---
layout: post
title: dlib提取人脸关键点的性能
date: 2017-12-12 20:00:00 +0800
categories: 人脸识别
tags: dlib
toc: true
comments: true
---
本章要点：
- dlib提取人脸关键点的时间性能和尺寸

<!-- more -->
来单独聊聊dlib提取人脸关键点的时间、空间性能。作者训练的[http://dlib.net/files/shape_predictor_68_face_landmarks.dat.bz2](http://dlib.net/files/shape_predictor_68_face_landmarks.dat.bz2)模型压缩后有61M，解压后99M，跑在服务端这不算什么，但是如果放在一个客户端产品里这么大的尺寸是不能接受的。

# 时间性能优化
时间性能开销更是慢得像屎一样，我在mac book pro 2013下，用python在每个视频帧上标出landmarks，我发现每次提取关键点需要700ms左右。代码如下：
``` python

class DLibHelper(object):
    def __init__(self):
        self.mParams = {'predictorPath':'extdata/shape_predictor_68_face_landmarks.dat', 
        'faceRecModelPath':'extdata/dlib_face_recognition_resnet_model_v1.dat'}
        self.ReloadFunctions()

    def ReloadFunctions(self):
        self.funcShapePredictor = dlib.shape_predictor(self.mParams['predictorPath'])
        self.funcFaceRecognize = dlib.face_recognition_model_v1(self.mParams['faceRecModelPath'])
        self.funcDetector = dlib.get_frontal_face_detector()

    def GetFaces(self, img):    # 返回所有脸盘
        return self.funcDetector(img, 1)

    def GetFaceLandmarks(self, img, faceRect):  # 返回指定脸盘的landmarks
        keyPts = self.funcShapePredictor(img, faceRect).parts()
        landmarks = numpy.matrix([[p.x, p.y] for p in keyPts])
        return landmarks

class DLibPerfUT(unittest.TestCase):
    def setUp(self):
        logFmt = '%(asctime)s %(lineno)04d %(levelname)-8s %(message)s'
        logging.basicConfig(level=logging.DEBUG, format=logFmt, datefmt='%H:%M',)

    def test02(self):
        ''' 从摄像头读取图像并显示 '''
        dlibHelper = DLibHelper()
        cap = cv2.VideoCapture(0)
        img = cap.read()[1]
        while True:
            img = cap.read()[1]
            t0= timeit.default_timer()

            faceRects = dlibHelper.GetFaces(img)  # 检测人脸rect
            if len(faceRects) == 0:
                continue

            t1= timeit.default_timer()
            faceRect = faceRects[0]

            landmarks = dlibHelper.GetFaceLandmarks(img, faceRect)  # 提取landmarks
            t2 = timeit.default_timer()
            logging.debug('GetFaces:%5.3f, GetFaceLandmarks:%5.3f' % (t1-t0, t2-t1))

            pts = numpy.array(landmarks, numpy.int32)
            cv2.polylines(img, pts.reshape(-1, 1, 2), True, (0, 255, 0), 2)

            cv2.imshow('image', img)
            key = cv2.waitKey(1)
            if key == 27:
                break
```
这段代码的输出结果如下：
``` bash
$ python -m unittest sample.DLibPerfUT.test02
23:36 0096 DEBUG    GetFaces:0.719, GetFaceLandmarks:0.004
23:37 0096 DEBUG    GetFaces:0.730, GetFaceLandmarks:0.004
23:37 0096 DEBUG    GetFaces:0.703, GetFaceLandmarks:0.004
23:37 0096 DEBUG    GetFaces:0.699, GetFaceLandmarks:0.004
23:37 0096 DEBUG    GetFaces:0.724, GetFaceLandmarks:0.004
23:37 0096 DEBUG    GetFaces:0.733, GetFaceLandmarks:0.004
23:37 0096 DEBUG    GetFaces:0.691, GetFaceLandmarks:0.004
23:37 0096 DEBUG    GetFaces:0.695, GetFaceLandmarks:0.004
23:37 0096 DEBUG    GetFaces:0.684, GetFaceLandmarks:0.004
23:37 0096 DEBUG    GetFaces:0.684, GetFaceLandmarks:0.004
23:37 0096 DEBUG    GetFaces:0.685, GetFaceLandmarks:0.004
```
这么慢的速度根本没法应用到实时视频上，不过很容易关注到瓶颈点是在人脸识别上，即脸部矩形的检测上，关键点检测倒是挺快的。

## 修改人脸检测器的参数
我在[face_detector.py](https://github.com/davisking/dlib/blob/master/python_examples/face_detector.py)中找到如下一段代码：
``` python
...
    img = io.imread(f)
    # The 1 in the second argument indicates that we should upsample the image
    # 1 time.  This will make everything bigger and allow us to detect more
    # faces.
    dets = detector(img, 1)
    ...
```
这段注释是说：`detector的第二个参数1表示会把图片扩大1倍，以便发现更多的面孔`，这也意味着要付出更大的性能代价。如果应用场景确定是单面孔，其实没必要扩大，因此我把这个数值改为0，发现时间消耗只剩原来的1/4！
``` bash
palancedeMacBook-Pro:faceRek palance$ python -m unittest sample.DLibPerfUT.test02
23:47 0096 DEBUG    GetFaces:0.171, GetFaceLandmarks:0.007
23:47 0096 DEBUG    GetFaces:0.165, GetFaceLandmarks:0.004
23:47 0096 DEBUG    GetFaces:0.164, GetFaceLandmarks:0.004
23:47 0096 DEBUG    GetFaces:0.162, GetFaceLandmarks:0.004
23:47 0096 DEBUG    GetFaces:0.163, GetFaceLandmarks:0.004
23:47 0096 DEBUG    GetFaces:0.160, GetFaceLandmarks:0.004
23:47 0096 DEBUG    GetFaces:0.159, GetFaceLandmarks:0.004
23:47 0096 DEBUG    GetFaces:0.164, GetFaceLandmarks:0.004
```

## 在小图上做人脸检测
已经很棒了，但是还不够。一般视频每秒钟在20~30帧，因此每帧的处理时间必须控制在30ms才能保证视频流畅。既然缩小图片尺寸可以有效减少时间开销，可以进一步沿着这个思路做优化。如果应用的场景中面孔不是很多，可以进一步缩小图片尺寸，使用缩小的图片做人脸检测，然后再等比扩大到初始尺寸，做landmark提取。由于人脸在图片中的面积通常比较大，所以缩放几乎不会影响人脸识别的精度，landmarks提取还是在原始图片上做的，精度也不受影响。我把代码改成这样：
``` python
...
    def test02(self):
        ''' 从摄像头读取图像并显示 '''
        dlibHelper = DLibHelper()
        cap = cv2.VideoCapture(0)
        img = cap.read()[1]
        while True:
            img = cap.read()[1]
            
            t0= timeit.default_timer()
            imgZoomed = cv2.resize(img, None, fx=0.25, fy=0.25, interpolation=cv2.INTER_CUBIC) # 缩小四分之一
            t1= timeit.default_timer()

            faceRects = dlibHelper.GetFaces(imgZoomed)  # 检测人脸rect
            if len(faceRects) == 0:
                continue

            t2= timeit.default_timer()
            faceRect = faceRects[0]
            faceRect = dlib.rectangle(faceRects[0].left()*4, faceRects[0].top()*4, 
                faceRects[0].right()*4, faceRects[0].bottom()*4)
            cv2.rectangle(img, (faceRect.left(), faceRect.top()), (faceRect.right(), faceRect.bottom()), (0, 255, 0), 1)

            landmarks = dlibHelper.GetFaceLandmarks(img, faceRect)  # 提取landmarks
            t3 = timeit.default_timer()
            logging.debug('GetFaces:%5.3f, GetFaceLandmarks:%5.3f' % (t2-t1, t3-t2))

            pts = numpy.array(landmarks, numpy.int32)
            cv2.polylines(img, pts.reshape(-1, 1, 2), True, (0, 255, 0), 2)

            cv2.imshow('image', img)
            key = cv2.waitKey(1)
            if key == 27:
                break
```
输出结果如下：
``` bash
$ python -m unittest sample.DLibPerfUT.test02
23:58 0095 DEBUG    GetFaces:0.013, GetFaceLandmarks:0.009
23:58 0095 DEBUG    GetFaces:0.012, GetFaceLandmarks:0.004
23:58 0095 DEBUG    GetFaces:0.011, GetFaceLandmarks:0.004
23:58 0095 DEBUG    GetFaces:0.012, GetFaceLandmarks:0.004
23:58 0095 DEBUG    GetFaces:0.012, GetFaceLandmarks:0.004
23:58 0095 DEBUG    GetFaces:0.012, GetFaceLandmarks:0.004
23:58 0095 DEBUG    GetFaces:0.012, GetFaceLandmarks:0.004
23:58 0095 DEBUG    GetFaces:0.011, GetFaceLandmarks:0.004
23:58 0095 DEBUG    GetFaces:0.012, GetFaceLandmarks:0.004
23:58 0095 DEBUG    GetFaces:0.017, GetFaceLandmarks:0.004
23:58 0095 DEBUG    GetFaces:0.011, GetFaceLandmarks:0.004
23:58 0095 DEBUG    GetFaces:0.012, GetFaceLandmarks:0.004
23:58 0095 DEBUG    GetFaces:0.011, GetFaceLandmarks:0.004
```
哈哈简直健步如飞！播放视频已经没问题了。


# 参考
[Speeding up Dlib’s Facial Landmark Detector](https://www.learnopencv.com/speeding-up-dlib-facial-landmark-detector/)