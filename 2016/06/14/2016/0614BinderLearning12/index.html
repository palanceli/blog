<!DOCTYPE html><html lang="zh-CN"><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description"><title>Binder学习笔记（十二）—— binder_transaction(...)都干了什么？ | Palance's Blog</title><link rel="stylesheet" type="text/css" href="/blog/css/style.css?v=0.0.0"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/normalize/4.1.1/normalize.min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/pure/0.6.0/pure-min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/pure/0.6.0/grids-responsive-min.css"><link rel="stylesheet" href="//cdn.bootcss.com/font-awesome/4.6.2/css/font-awesome.min.css"><script type="text/javascript" src="//cdn.bootcss.com/jquery/2.2.3/jquery.min.js"></script><link rel="Shortcut Icon" type="image/x-icon" href="/blog/favicon.ico"><link rel="apple-touch-icon" href="/blog/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/blog/apple-touch-icon.png"></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">Binder学习笔记（十二）—— binder_transaction(...)都干了什么？</h1><a id="logo" href="/blog/.">Palance's Blog</a><p class="description"></p></div><div id="nav-menu"><a href="/blog/." class="current"><i class="fa fa-home"> 首页</i></a><a href="/blog/archives/"><i class="fa fa-archive"> 归档</i></a><a href="/blog/about/"><i class="fa fa-user"> 关于</i></a><a href="/blog/atom.xml"><i class="fa fa-rss"> 订阅</i></a></div></div><div id="layout" class="pure-g"><div class="pure-u-1 pure-u-md-3-4"><div class="content_container"><div class="post"><h1 class="post-title">Binder学习笔记（十二）—— binder_transaction(...)都干了什么？</h1><div class="post-meta">Jun 14, 2016<span> | </span><span class="category"><a href="/blog/categories/Android/">Android</a></span><script src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js" async></script><span id="busuanzi_container_page_pv"> | <span id="busuanzi_value_page_pv"></span><span> Hits</span></span></div><a data-disqus-identifier="2016/06/14/2016/0614BinderLearning12/" href="/blog/2016/06/14/2016/0614BinderLearning12/#disqus_thread" class="disqus-comment-count"></a><div class="clear"><div id="toc" class="toc-article"><div class="toc-title">文章目录</div><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#binder-open-…-都干了什么？"><span class="toc-number">1.</span> <span class="toc-text">binder_open(…)都干了什么？</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#struct-binder-proc"><span class="toc-number">1.1.</span> <span class="toc-text">struct binder_proc</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#binder-proc中的链表"><span class="toc-number">1.2.</span> <span class="toc-text">binder_proc中的链表</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#INIT-LIST-HEAD-amp-proc-gt-todo"><span class="toc-number">1.3.</span> <span class="toc-text">INIT_LIST_HEAD(&proc->todo)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#init-waitqueue-head-amp-proc-gt-wait"><span class="toc-number">1.4.</span> <span class="toc-text">init_waitqueue_head(&proc->wait)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#hlist-add-head-amp-proc-gt-proc-node-amp-binder-procs"><span class="toc-number">1.5.</span> <span class="toc-text">hlist_add_head(&proc->proc_node, &binder_procs)</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#binder-mmap-…-都干了什么？"><span class="toc-number">2.</span> <span class="toc-text">binder_mmap(…)都干了什么？</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#binder-update-page-range-…-做了什么"><span class="toc-number">2.1.</span> <span class="toc-text">binder_update_page_range(…)做了什么</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#struct-binder-buffer"><span class="toc-number">2.2.</span> <span class="toc-text">struct binder_buffer</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#list-add-amp-buffer-gt-entry-amp-proc-gt-buffers"><span class="toc-number">2.3.</span> <span class="toc-text">list_add(&buffer->entry, &proc->buffers)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#函数binder-insert-free-buffer-…"><span class="toc-number">2.4.</span> <span class="toc-text">函数binder_insert_free_buffer(…)</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#从服务端addService触发的binder-transaction"><span class="toc-number">3.</span> <span class="toc-text">从服务端addService触发的binder_transaction(...)</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#struct-binder-transaction"><span class="toc-number">3.1.</span> <span class="toc-text">struct binder_transaction</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#struct-binder-work"><span class="toc-number">3.2.</span> <span class="toc-text">struct binder_work</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#struct-binder-node"><span class="toc-number">3.3.</span> <span class="toc-text">struct binder_node</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#struct-binder-ref"><span class="toc-number">3.4.</span> <span class="toc-text">struct binder_ref</span></a></li></ol></li></ol></div></div><div class="post-content"><h1 id="binder-open-…-都干了什么？"><a href="#binder-open-…-都干了什么？" class="headerlink" title="binder_open(…)都干了什么？"></a>binder_open(…)都干了什么？</h1><p>在回答binder_transaction(…)之前，还有一些基础设施要去探究，比如binder_open(…)，binder_mmap(…)，这些调用是在打开设备文件/dev/binder之后必须完成的程式化操作，而在它们内部需要做一些数据结构的准备。首先来看binder_open(…)<br>kernel/drivers/staging/android/binder.c:2979<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">binder_open</span><span class="params">(<span class="keyword">struct</span> inode *nodp, <span class="keyword">struct</span> file *filp)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    <span class="keyword">struct</span> binder_proc *proc;</span><br><span class="line">    ......</span><br><span class="line">    proc = kzalloc(sizeof(*proc), GFP_KERNEL); <span class="comment">// 创建binder_proc结构体</span></span><br><span class="line">    ......</span><br><span class="line">    get_task_struct(current);</span><br><span class="line">    proc-&gt;tsk = current;</span><br><span class="line">    INIT_LIST_HEAD(&amp;proc-&gt;todo);  <span class="comment">// 初始化链表头</span></span><br><span class="line">    init_waitqueue_head(&amp;proc-&gt;wait);   </span><br><span class="line">    proc-&gt;default_priority = task_nice(current);</span><br><span class="line"></span><br><span class="line">    ......</span><br><span class="line">    <span class="comment">// 将proc_node串入全局链表binder_procs中</span></span><br><span class="line">    hlist_add_head(&amp;proc-&gt;proc_node, &amp;binder_procs); </span><br><span class="line">    proc-&gt;pid = current-&gt;group_leader-&gt;pid;</span><br><span class="line">    INIT_LIST_HEAD(&amp;proc-&gt;delivered_death);</span><br><span class="line">    filp-&gt;private_data = proc;</span><br><span class="line"></span><br><span class="line">    ......</span><br><span class="line">    return <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>binder_open(…)生成并初始化binder_proc结构体如下：<br><img src="img04.png" alt="binder_open(...)初始化的binder_proc结构体"></p>
<h2 id="struct-binder-proc"><a href="#struct-binder-proc" class="headerlink" title="struct binder_proc"></a>struct binder_proc</h2><p>struct binder_proc描述一个“正在使用Binder进程间通信机制”的进程，它的定义参见kernel/goldfish/drivers/staging/android/binder.c:286<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> binder_proc &#123;</span><br><span class="line">    <span class="comment">// 进程打开设备文件/dev/binder时，Binder驱动会为它创建一个binder_proc结构体，并将它</span></span><br><span class="line">    <span class="comment">// 保存在全局hash列表中，proc_node是该hash列表的节点。</span></span><br><span class="line">    <span class="keyword">struct</span> hlist_node proc_node;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 每个使用了Binder机制的进程都有一个Binder线程池，用来处理进程间通信请求。threads以</span></span><br><span class="line">    <span class="comment">// 线程ID作为key来组织进程的Binder线程池。进程可以调用ioctl将线程注册到Binder驱动中</span></span><br><span class="line">    <span class="comment">// 当没有足够的空闲线程处理进程间通信请求时，驱动可以要求进程注册更多的线程到Binder线程</span></span><br><span class="line">    <span class="comment">// 池中</span></span><br><span class="line">    <span class="keyword">struct</span> rb_root threads; </span><br><span class="line"></span><br><span class="line">    <span class="keyword">struct</span> rb_root nodes;           <span class="comment">// 组织Binder实体对象，它以成员ptr作为key</span></span><br><span class="line">    <span class="keyword">struct</span> rb_root refs_by_desc;    <span class="comment">// 组织Binder引用对象，它以成员desc作为key</span></span><br><span class="line">    <span class="keyword">struct</span> rb_root refs_by_node;    <span class="comment">// 组织Binder引用对象，它以成员node作为key</span></span><br><span class="line">    <span class="keyword">int</span> pid;                        <span class="comment">// 指向进程组ID</span></span><br><span class="line">    <span class="keyword">struct</span> vm_area_struct *vma;     <span class="comment">// 内核缓冲区的用户空间地址，供应用程序使用</span></span><br><span class="line">    <span class="keyword">struct</span> mm_struct *vma_vm_mm;</span><br><span class="line">    <span class="keyword">struct</span> task_struct *tsk;        <span class="comment">// 指向进程任务控制块</span></span><br><span class="line">    <span class="keyword">struct</span> files_struct *files;     <span class="comment">// 指向进程打开文件结构体数组</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 一个hash表，保存进程可以延迟执行的工作项，这些延迟工作有三种类型</span></span><br><span class="line">    <span class="comment">// BINDER_DEFERRED_PUT_FILES、BINDER_DEFERRED_FLUSH、BINDER_DEFERRED_RELEASE</span></span><br><span class="line">    <span class="comment">// 驱动为进程分配内核缓冲区时，会为该缓冲区创建一个文件描述符，进程可以通过该描述符将该内</span></span><br><span class="line">    <span class="comment">// 核缓冲区映射到自己的地址空间。当进程不再需要使用Binder机制时，就会通知驱动关闭该文件</span></span><br><span class="line">    <span class="comment">// 描述符并释放之前所分配的内核缓冲区。由于这不是一个马上就要完成的操作，因此驱动会创建一</span></span><br><span class="line">    <span class="comment">// 个BINDER_DEFERRED_PUT_FILES类型的工作来延迟执行；</span></span><br><span class="line">    <span class="comment">// Binder线程池中的空闲Binder线程是睡眠在一个等待队列中的，进程可以通过调用函数flush</span></span><br><span class="line">    <span class="comment">// 来唤醒这些线程，以便它们可以检查进程是否有新的工作项需要处理。此时驱动会创建一个</span></span><br><span class="line">    <span class="comment">// BINDER_DEFERRED_FLUSH类型的工作项，以便延迟执行唤醒空闲Binder线程的操作；</span></span><br><span class="line">    <span class="comment">// 当进程不再使用Binder机制时，会调用函数close关闭文件/dev/binder，此时驱动会释放之</span></span><br><span class="line">    <span class="comment">// 前为它分配的资源，由于资源释放是个比较耗时的操作，驱动会创建一个</span></span><br><span class="line">    <span class="comment">// BINDER_DEFERRED_RELEASE类型的事务来延迟执行</span></span><br><span class="line">    <span class="keyword">struct</span> hlist_node deferred_work_node;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> deferred_work;              <span class="comment">// 描述该延迟工作项的具体类型</span></span><br><span class="line">    <span class="keyword">void</span> *buffer;                   <span class="comment">// 内核缓冲区的内核空间地址，供驱动程序使用</span></span><br><span class="line">    <span class="keyword">ptrdiff_t</span> user_buffer_offset;   <span class="comment">// vma和buffer之间的差值</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// buffer指向一块大的内核缓冲区，驱动程序为方便管理，将它划分成若干小块，这些小块的内核缓</span></span><br><span class="line">    <span class="comment">// 冲区用binder_buffer描述保存在列表中，按地址从小到大排列。buffers指向该列表的头部。</span></span><br><span class="line">    <span class="keyword">struct</span> list_head buffers; </span><br><span class="line"></span><br><span class="line">    <span class="keyword">struct</span> rb_root free_buffers;      <span class="comment">// buffers中的小块有的正在使用，被保存在此红黑树</span></span><br><span class="line">    <span class="keyword">struct</span> rb_root allocated_buffers;   <span class="comment">// buffers中的空闲小块被保存在此红黑树</span></span><br><span class="line">    <span class="keyword">size_t</span> free_async_space;            <span class="comment">// 当前可用的保存异步事务数据的内核缓冲区的大小</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">struct</span> page **pages;    <span class="comment">// buffer和vma都是虚拟地址，它们对应的物理页面保存在pages</span></span><br><span class="line">                            <span class="comment">// 中，这是一个数组，每个元素指向一个物理页面</span></span><br><span class="line">    <span class="keyword">size_t</span> buffer_size;     <span class="comment">// 进程调用mmap将它映射到进程地址空间，实际上是请求驱动为它</span></span><br><span class="line">                            <span class="comment">// 分配一块内核缓冲区，缓冲区大小保存在该成员中</span></span><br><span class="line">    <span class="keyword">uint32_t</span> buffer_free;   <span class="comment">// 空闲内核缓冲区的大小</span></span><br><span class="line">    <span class="keyword">struct</span> list_head todo;  <span class="comment">// 当进程接收到一个进程间通信请求时，Binder驱动就将该请求封</span></span><br><span class="line">                            <span class="comment">// 装成一个工作项，并且加入到进程的待处理工作向队列中，该队列</span></span><br><span class="line">                            <span class="comment">// 使用成员变量todo来描述。</span></span><br><span class="line">    <span class="keyword">wait_queue_head_t</span> wait; <span class="comment">// 线程池中空闲Binder线程会睡眠在由该成员所描述的等待队列中</span></span><br><span class="line">                            <span class="comment">// 当宿主进程的待处理工作项队列增加新工作项后，驱动会唤醒这</span></span><br><span class="line">                            <span class="comment">// 些线程，以便处理新的工作项</span></span><br><span class="line">    <span class="keyword">struct</span> binder_stats stats;  <span class="comment">// 用来统计进程数据</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 当进程所引用的Service组件死亡时，驱动会向该进程发送一个死亡通知。这个正在发出的通知被</span></span><br><span class="line">    <span class="comment">// 封装成一个类型为BINDER_WORK_DEAD_BINDER或BINDER_WORK_DEAD_BINDER_AND_CLEAR</span></span><br><span class="line">    <span class="comment">// 的工作项，并保存在由该成员描述的队列中删除</span></span><br><span class="line">    <span class="keyword">struct</span> list_head delivered_death;  </span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> max_threads;        <span class="comment">// 驱动程序最多可以主动请求进程注册的线程数</span></span><br><span class="line">    <span class="keyword">int</span> requested_threads;</span><br><span class="line">    <span class="keyword">int</span> requested_threads_started;</span><br><span class="line">    <span class="keyword">int</span> ready_threads;      <span class="comment">// 进程当前的空闲Binder线程数</span></span><br><span class="line">    <span class="keyword">long</span> default_priority;  <span class="comment">// 进程的优先级，当线程处理一个工作项时，线程优先级可能被</span></span><br><span class="line">                            <span class="comment">// 设置为宿主进程的优先级</span></span><br><span class="line">    <span class="keyword">struct</span> dentry *debugfs_entry;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h2 id="binder-proc中的链表"><a href="#binder-proc中的链表" class="headerlink" title="binder_proc中的链表"></a>binder_proc中的链表</h2><p>在binder_proc内部有若干个list_head类型的字段，用来把binder_proc串到不同的链表中去。一般写链表的做法是在链表节点结构体中追加业务逻辑字段，顺着链表的prev、next指针到达指定节点，然后再访问业务逻辑字段：<br><img src="img01.png" alt="一般的链表做法"><br>在Linux代码中则常常反过来，先定义业务逻辑的结构体，在其内部嵌入链表字段list_head，顺着该字段遍历链表，在每个节点上根据该字段与所在结构体的偏移量找到所在结构体，访问业务逻辑字段：<br><img src="img02.png" alt="Linux中常用的链表做法"><br>这样做的好处是让业务逻辑和链表逻辑分离，Linux还定义了宏用于操作链表，以及根据链表字段找到所在结构体。如binder_proc结构体内部盛放多个list_head，表示把该结构体串入了不同的链表。<br>具体技巧可参见《Linux内核设计与实现》第6章。</p>
<h2 id="INIT-LIST-HEAD-amp-proc-gt-todo"><a href="#INIT-LIST-HEAD-amp-proc-gt-todo" class="headerlink" title="INIT_LIST_HEAD(&amp;proc-&gt;todo)"></a>INIT_LIST_HEAD(&amp;proc-&gt;todo)</h2><p>回到binder_open(…)，除了直接字段赋值，需要解释的是几个链表字段的处理。<br><code>INIT_LIST_HEAD(&amp;proc-&gt;todo)</code>用于将todo的next、prev指针指向自己，该宏的定义在kernel/goldfish/include/linux/lish.t:24<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">INIT_LIST_HEAD</span><span class="params">(<span class="keyword">struct</span> list_head *<span class="built_in">list</span>)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    <span class="built_in">list</span>-&gt;next = <span class="built_in">list</span>;</span><br><span class="line">    <span class="built_in">list</span>-&gt;prev = <span class="built_in">list</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="init-waitqueue-head-amp-proc-gt-wait"><a href="#init-waitqueue-head-amp-proc-gt-wait" class="headerlink" title="init_waitqueue_head(&amp;proc-&gt;wait)"></a>init_waitqueue_head(&amp;proc-&gt;wait)</h2><p><code>init_waitqueue_head(&amp;proc-&gt;wait)</code>这个宏定义在kernel/goldfish/include/linux/wait.h:81<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> init_waitqueue_head(q)              \</span><br><span class="line">    do &#123;                        \</span><br><span class="line">        static struct lock_class_key __key; \</span><br><span class="line">                            \</span><br><span class="line">        __init_waitqueue_head((q), #q, &amp;__key); \</span><br><span class="line">    &#125; while (0)</span></span><br></pre></td></tr></table></figure></p>
<p><code>__init_waitqueue_head(...)</code>定义在kernel/goldfish/kernel/wait.c:13，主要完成了对task_list字段的初始化：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> __init_waitqueue_head(<span class="keyword">wait_queue_head_t</span> *q, <span class="keyword">const</span> <span class="keyword">char</span> *name, <span class="keyword">struct</span> lock_class_key *key)</span><br><span class="line"><span class="comment">// q=(&amp;proc-&gt;todo)</span></span><br><span class="line">&#123;</span><br><span class="line">    spin_lock_init(&amp;q-&gt;lock);</span><br><span class="line">    lockdep_set_class_and_name(&amp;q-&gt;lock, key, name);</span><br><span class="line">    INIT_LIST_HEAD(&amp;q-&gt;task_list);  <span class="comment">// 为什么使用符号-&gt;来提领task_list呢？</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>说到底还是初始化proc-&gt;wait-&gt;task_list字段。不过有点奇怪task_list是wait内的结构体，而不是结构体指针，为什么对task_list的提领使用符号<code>-&gt;</code>呢？<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> binder_proc &#123;</span><br><span class="line">    ......</span><br><span class="line">    <span class="keyword">wait_queue_head_t</span> wait;</span><br><span class="line">    ......</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>kernel/goldfish/include/linux/wait.h:53<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> __wait_queue_head &#123;</span><br><span class="line">    <span class="keyword">spinlock_t</span> lock;</span><br><span class="line">    <span class="keyword">struct</span> list_head task_list;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> __wait_queue_head <span class="keyword">wait_queue_head_t</span>;</span><br></pre></td></tr></table></figure></p>
<h2 id="hlist-add-head-amp-proc-gt-proc-node-amp-binder-procs"><a href="#hlist-add-head-amp-proc-gt-proc-node-amp-binder-procs" class="headerlink" title="hlist_add_head(&amp;proc-&gt;proc_node, &amp;binder_procs)"></a>hlist_add_head(&amp;proc-&gt;proc_node, &amp;binder_procs)</h2><p><code>hlist_add_head(&amp;proc-&gt;proc_node, &amp;binder_procs)</code>将proc-&gt;proc_node节点串到全局链表binder_procs的头部，其定义在kernel/goldfish/include/linux/list.h:610<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">hlist_add_head</span><span class="params">(<span class="keyword">struct</span> hlist_node *n, <span class="keyword">struct</span> hlist_head *h)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    <span class="keyword">struct</span> hlist_node *first = h-&gt;first;</span><br><span class="line">    n-&gt;next = first;</span><br><span class="line">    <span class="keyword">if</span> (first)</span><br><span class="line">        first-&gt;pprev = &amp;n-&gt;next;</span><br><span class="line">    h-&gt;first = n;</span><br><span class="line">    n-&gt;pprev = &amp;h-&gt;first;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>kernel/goldfish/include/linux/types.h:233<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> hlist_head &#123;</span><br><span class="line">    <span class="keyword">struct</span> hlist_node *first;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> hlist_node &#123;</span><br><span class="line">    <span class="keyword">struct</span> hlist_node *next, **pprev;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p><img src="img05.png" alt="将n插入到h"></p>
<p><img src="img06.png" alt="插入后的结果"><br>综上所述，binder_open(…)组织的数据结构proc为：<br><img src="img04.png" alt="binder_open(...)组织的proc数据结构图"></p>
<h1 id="binder-mmap-…-都干了什么？"><a href="#binder-mmap-…-都干了什么？" class="headerlink" title="binder_mmap(…)都干了什么？"></a>binder_mmap(…)都干了什么？</h1><p>接下来就是binder_mmap(…)，当进程打开/dev/binder之后，必须调用mmap(…)函数把该文件映射到进程的地址空间。<br>kernel/goldfish/drivers/staging/android/binder.c:2883<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">binder_mmap</span><span class="params">(<span class="keyword">struct</span> file *filp, <span class="keyword">struct</span> vm_area_struct *vma)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ret;</span><br><span class="line">    <span class="keyword">struct</span> vm_struct *area; <span class="comment">// area描述内核地址空间；vma描述用户地址空间</span></span><br><span class="line">    <span class="keyword">struct</span> binder_proc *proc = filp-&gt;private_data;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *failure_string;</span><br><span class="line">    <span class="keyword">struct</span> binder_buffer *buffer;</span><br><span class="line"></span><br><span class="line">    ......</span><br><span class="line">    vma-&gt;vm_flags = (vma-&gt;vm_flags | VM_DONTCOPY) &amp; ~VM_MAYWRITE;</span><br><span class="line"></span><br><span class="line">    ......</span><br><span class="line">    <span class="comment">// 在内核地址空间分配</span></span><br><span class="line">    area = get_vm_area(vma-&gt;vm_end - vma-&gt;vm_start, VM_IOREMAP);</span><br><span class="line">    ......</span><br><span class="line">    proc-&gt;buffer = area-&gt;addr;</span><br><span class="line">    proc-&gt;user_buffer_offset = vma-&gt;vm_start - (<span class="keyword">uintptr_t</span>)proc-&gt;buffer;</span><br><span class="line">    mutex_unlock(&amp;binder_mmap_lock);</span><br><span class="line">......</span><br><span class="line">    <span class="comment">// 创建物理页面结构体指针数组</span></span><br><span class="line">    proc-&gt;pages = kzalloc(sizeof(proc-&gt;pages[<span class="number">0</span>]) * ((vma-&gt;vm_end - vma-&gt;vm_start) / PAGE_SIZE), GFP_KERNEL);</span><br><span class="line">    ......</span><br><span class="line">    proc-&gt;buffer_size = vma-&gt;vm_end - vma-&gt;vm_start;</span><br><span class="line"></span><br><span class="line">    vma-&gt;vm_ops = &amp;binder_vm_ops;</span><br><span class="line">    vma-&gt;vm_private_data = proc;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 分配物理页面，并将之同时映射到用户和内核地址空间</span></span><br><span class="line">    <span class="keyword">if</span> (binder_update_page_range(proc, <span class="number">1</span>, proc-&gt;buffer, proc-&gt;buffer + PAGE_SIZE, vma)) &#123;</span><br><span class="line">        ret = -ENOMEM;</span><br><span class="line">        failure_string = <span class="string">"alloc small buf"</span>;</span><br><span class="line">        <span class="keyword">goto</span> err_alloc_small_buf_failed;</span><br><span class="line">    &#125;</span><br><span class="line">    buffer = proc-&gt;buffer;</span><br><span class="line">    INIT_LIST_HEAD(&amp;proc-&gt;buffers);</span><br><span class="line">    list_add(&amp;buffer-&gt;entry, &amp;proc-&gt;buffers); <span class="comment">// 把entry串到buffers链表中</span></span><br><span class="line">    buffer-&gt;<span class="built_in">free</span> = <span class="number">1</span>;</span><br><span class="line">    binder_insert_free_buffer(proc, buffer);</span><br><span class="line">    proc-&gt;free_async_space = proc-&gt;buffer_size / <span class="number">2</span>;</span><br><span class="line">    barrier();</span><br><span class="line">    proc-&gt;files = get_files_struct(proc-&gt;tsk);</span><br><span class="line">    proc-&gt;vma = vma;</span><br><span class="line">    proc-&gt;vma_vm_mm = vma-&gt;vm_mm;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*printk(KERN_INFO "binder_mmap: %d %lx-%lx maps %p\n",</span><br><span class="line">         proc-&gt;pid, vma-&gt;vm_start, vma-&gt;vm_end, proc-&gt;buffer);*/</span></span><br><span class="line">    return <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">err_alloc_small_buf_failed:</span><br><span class="line">    kfree(proc-&gt;pages);</span><br><span class="line">    proc-&gt;pages = <span class="literal">NULL</span>;</span><br><span class="line">err_alloc_pages_failed:</span><br><span class="line">    mutex_lock(&amp;binder_mmap_lock);</span><br><span class="line">    vfree(proc-&gt;buffer);</span><br><span class="line">    proc-&gt;buffer = <span class="literal">NULL</span>;</span><br><span class="line">err_get_vm_area_failed:</span><br><span class="line">err_already_mapped:</span><br><span class="line">    mutex_unlock(&amp;binder_mmap_lock);</span><br><span class="line">err_bad_arg:</span><br><span class="line">    printk(KERN_ERR <span class="string">"binder_mmap: %d %lx-%lx %s failed %d\n"</span>,</span><br><span class="line">           proc-&gt;pid, vma-&gt;vm_start, vma-&gt;vm_end, failure_string, ret);</span><br><span class="line">    return ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>到第28行调用binder_update_page_range(…)之前，binder_mmap(…)在内核地址空间申请了<code>struct vm_struct area</code>，并完成部分成员的初始化，如下：<br><img src="img07.png" alt="到28行为止binder_mmap(...)构造的数据结构"></p>
<h2 id="binder-update-page-range-…-做了什么"><a href="#binder-update-page-range-…-做了什么" class="headerlink" title="binder_update_page_range(…)做了什么"></a>binder_update_page_range(…)做了什么</h2><p>kernel/goldfish/drivers/staging/android/binder.c:627<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">binder_update_page_range</span><span class="params">(<span class="keyword">struct</span> binder_proc *proc, <span class="keyword">int</span> allocate,</span><br><span class="line">                    <span class="keyword">void</span> *start, <span class="keyword">void</span> *end,</span><br><span class="line">                    <span class="keyword">struct</span> vm_area_struct *vma)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    <span class="keyword">void</span> *page_addr;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> user_page_addr;</span><br><span class="line">    <span class="keyword">struct</span> vm_struct tmp_area;</span><br><span class="line">    <span class="keyword">struct</span> page **page;</span><br><span class="line">    <span class="keyword">struct</span> mm_struct *mm;</span><br><span class="line"></span><br><span class="line">    ... ...</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (vma)</span><br><span class="line">        mm = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        mm = get_task_mm(proc-&gt;tsk);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (mm) &#123;</span><br><span class="line">        down_write(&amp;mm-&gt;mmap_sem);</span><br><span class="line">        vma = proc-&gt;vma;</span><br><span class="line">        ... ...</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (allocate == <span class="number">0</span>) </span><br><span class="line">        <span class="keyword">goto</span> free_range;    <span class="comment">// 执行释放逻辑</span></span><br><span class="line"></span><br><span class="line">    ... ...</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 遍历所有页面</span></span><br><span class="line">    <span class="keyword">for</span> (page_addr = start; page_addr &lt; end; page_addr += PAGE_SIZE) &#123;</span><br><span class="line">        <span class="keyword">int</span> ret;</span><br><span class="line">        <span class="keyword">struct</span> page **page_array_ptr;</span><br><span class="line">        page = &amp;proc-&gt;pages[(page_addr - proc-&gt;buffer) / PAGE_SIZE];</span><br><span class="line"></span><br><span class="line">        BUG_ON(*page);</span><br><span class="line">        *page = alloc_page(GFP_KERNEL | __GFP_HIGHMEM | __GFP_ZERO);</span><br><span class="line">        ... ...</span><br><span class="line">        <span class="comment">// 映射内核地址空间</span></span><br><span class="line">        tmp_area.addr = page_addr;</span><br><span class="line">        tmp_area.size = PAGE_SIZE + PAGE_SIZE <span class="comment">/* guard page? */</span>;</span><br><span class="line">        page_array_ptr = page;</span><br><span class="line">        ret = map_vm_area(&amp;tmp_area, PAGE_KERNEL, &amp;page_array_ptr);</span><br><span class="line">        ... ...</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 映射用户地址空间</span></span><br><span class="line">        user_page_addr =</span><br><span class="line">            (<span class="keyword">uintptr_t</span>)page_addr + proc-&gt;user_buffer_offset;</span><br><span class="line">        ret = vm_insert_page(vma, user_page_addr, page[<span class="number">0</span>]);</span><br><span class="line">        ... ...</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (mm) &#123;</span><br><span class="line">        up_write(&amp;mm-&gt;mmap_sem);</span><br><span class="line">        mmput(mm);</span><br><span class="line">    &#125;</span><br><span class="line">    return <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">free_range:</span><br><span class="line">    <span class="keyword">for</span> (page_addr = end - PAGE_SIZE; page_addr &gt;= start;</span><br><span class="line">         page_addr -= PAGE_SIZE) &#123;</span><br><span class="line">        page = &amp;proc-&gt;pages[(page_addr - proc-&gt;buffer) / PAGE_SIZE];</span><br><span class="line">        <span class="comment">// 解除物理页面在用户地址空间和内核地址空间的映射</span></span><br><span class="line">        <span class="keyword">if</span> (vma)</span><br><span class="line">            zap_page_range(vma, (<span class="keyword">uintptr_t</span>)page_addr +</span><br><span class="line">                proc-&gt;user_buffer_offset, PAGE_SIZE, <span class="literal">NULL</span>);</span><br><span class="line">err_vm_insert_page_failed:</span><br><span class="line">        unmap_kernel_range((unsigned long)page_addr, PAGE_SIZE);</span><br><span class="line">err_map_kernel_failed:</span><br><span class="line">        __free_page(*page);     <span class="comment">// 释放物理页面</span></span><br><span class="line">        *page = <span class="literal">NULL</span>;</span><br><span class="line">err_alloc_page_failed:</span><br><span class="line">        ;</span><br><span class="line">    &#125;</span><br><span class="line">err_no_vma:</span><br><span class="line">    <span class="keyword">if</span> (mm) &#123;</span><br><span class="line">        up_write(&amp;mm-&gt;mmap_sem);</span><br><span class="line">        mmput(mm);</span><br><span class="line">    &#125;</span><br><span class="line">    return -ENOMEM;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="struct-binder-buffer"><a href="#struct-binder-buffer" class="headerlink" title="struct binder_buffer"></a>struct binder_buffer</h2><p>之后在binder_mmap(…)第34行，buffer的类型是<code>struct binder_buffer*</code>，该结构体用来描述一个内核缓冲区，该缓冲区用于在进程间传输数据。<br>kernel/goldfish/drivers/staging/android/binder.c:263<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> binder_buffer &#123;</span><br><span class="line">    <span class="comment">// 每一个使用Binder机制的进程在Binder驱动中都有一个内核缓冲区列表，用来保存Binder驱动</span></span><br><span class="line">    <span class="comment">// 程序为它分配的内核缓冲区，entry是该列表的一个节点</span></span><br><span class="line">    <span class="keyword">struct</span> list_head entry; <span class="comment">/* free and allocated entries by address */</span> </span><br><span class="line"></span><br><span class="line">    <span class="comment">// 进程使用两个红黑树分别保存使用中以及空闲的内核缓冲区。如果空闲，free=1，</span></span><br><span class="line">    <span class="comment">//rb_node就是空闲内核缓冲区红黑树中的节点，否则是使用中内核缓冲区红黑树中的节点</span></span><br><span class="line">    <span class="keyword">struct</span> rb_node rb_node; <span class="comment">/* free entry by size or allocated entry */</span> </span><br><span class="line">                         <span class="comment">/* by address */</span>                       </span><br><span class="line"></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="built_in">free</span>:<span class="number">1</span>;</span><br><span class="line">    <span class="comment">// Service处理完成该事务后，若发现allow_user_free为1，会请求驱动程序释放该内核缓冲区</span></span><br><span class="line">    <span class="keyword">unsigned</span> allow_user_free:<span class="number">1</span>;         </span><br><span class="line">    <span class="keyword">unsigned</span> async_transaction:<span class="number">1</span>;           <span class="comment">// 与该内核缓冲区关联的是一个异步事务</span></span><br><span class="line">    <span class="keyword">unsigned</span> debug_id:<span class="number">29</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">struct</span> binder_transaction *transaction; <span class="comment">// 内核缓冲区正交给哪个事务使用</span></span><br><span class="line">    <span class="keyword">struct</span> binder_node *target_node;        <span class="comment">// 内核缓冲区正交给哪个Binder实体对象使用</span></span><br><span class="line">    <span class="keyword">size_t</span> data_size;</span><br><span class="line">    <span class="keyword">size_t</span> offsets_size;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 保存通信数据，分两种类型：普通数据、Binder对象。驱动程序不关心普通数据，但必须知道里面</span></span><br><span class="line">    <span class="comment">// 的Binder对象，因为要根据它们来维护内核中Binder实体对象和Binder引用对象的生命周期。</span></span><br><span class="line">    <span class="keyword">uint8_t</span> data[<span class="number">0</span>];                        </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h2 id="list-add-amp-buffer-gt-entry-amp-proc-gt-buffers"><a href="#list-add-amp-buffer-gt-entry-amp-proc-gt-buffers" class="headerlink" title="list_add(&amp;buffer-&gt;entry, &amp;proc-&gt;buffers)"></a>list_add(&amp;buffer-&gt;entry, &amp;proc-&gt;buffers)</h2><p>初始化完proc-&gt;buffers之后，第36行执行一个list_add(…)，该函数定义见kernel/goldfish/include/linux/list.h:37~60<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">void</span> __list_add(<span class="keyword">struct</span> list_head *new,</span><br><span class="line">                  <span class="keyword">struct</span> list_head *prev,</span><br><span class="line">                  <span class="keyword">struct</span> list_head *next)</span><br><span class="line">&#123;</span><br><span class="line">    next-&gt;prev = new;</span><br><span class="line">    new-&gt;next = next;</span><br><span class="line">    new-&gt;prev = prev;</span><br><span class="line">    prev-&gt;next = new;</span><br><span class="line">&#125;</span><br><span class="line">... ...</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">list_add</span><span class="params">(<span class="keyword">struct</span> list_head *new, <span class="keyword">struct</span> list_head *head)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    __list_add(new, head, head-&gt;next);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>运算过程如下图：<br><img src="img08.png" alt="list_add操作过程"><br>于是到<code>binder_mmap(...)</code>第37行为止，binder_mmap(…)构造的数据结构如下：<br><img src="img09.png" alt="到37行为止binder_mmap(...)构造的数据结构"></p>
<h2 id="函数binder-insert-free-buffer-…"><a href="#函数binder-insert-free-buffer-…" class="headerlink" title="函数binder_insert_free_buffer(…)"></a>函数binder_insert_free_buffer(…)</h2><p>kernel/goldfish/drivers/statging/android/binder.c:545<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">binder_insert_free_buffer</span><span class="params">(<span class="keyword">struct</span> binder_proc *proc,</span><br><span class="line">                      <span class="keyword">struct</span> binder_buffer *new_buffer)</span></span><br><span class="line"></span>&#123;   <span class="comment">// new_buffer就是之前分配的buffer，被转型成了binder_buffer</span></span><br><span class="line">    <span class="keyword">struct</span> rb_node **p = &amp;proc-&gt;free_buffers.rb_node;</span><br><span class="line">    <span class="keyword">struct</span> rb_node *parent = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">struct</span> binder_buffer *buffer;</span><br><span class="line">    <span class="keyword">size_t</span> buffer_size;</span><br><span class="line">    <span class="keyword">size_t</span> new_buffer_size;</span><br><span class="line">    ... ...</span><br><span class="line">    <span class="comment">// 计算binder_buffer中data部分的大小</span></span><br><span class="line">    new_buffer_size = binder_buffer_size(proc, new_buffer);</span><br><span class="line"></span><br><span class="line">    ... ...</span><br><span class="line">    <span class="comment">// 根据new_buffer的大小，找到在proc-&gt;free_buffers红黑树中的正确位置，并插入</span></span><br><span class="line">    <span class="keyword">while</span> (*p) &#123;</span><br><span class="line">        parent = *p;</span><br><span class="line">        buffer = rb_entry(parent, struct binder_buffer, rb_node);</span><br><span class="line">        BUG_ON(!buffer-&gt;<span class="built_in">free</span>);</span><br><span class="line"></span><br><span class="line">        buffer_size = binder_buffer_size(proc, buffer);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (new_buffer_size &lt; buffer_size)</span><br><span class="line">            p = &amp;parent-&gt;rb_left;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            p = &amp;parent-&gt;rb_right;</span><br><span class="line">    &#125;</span><br><span class="line">    rb_link_node(&amp;new_buffer-&gt;rb_node, parent, p);</span><br><span class="line">    rb_insert_color(&amp;new_buffer-&gt;rb_node, &amp;proc-&gt;free_buffers);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>于是到binder_mmap(…)结束，这个binder_proc结构体就被做成了这样：<br><img src="img10.png" alt="binder_mmap(...)调用完成后构造的binder_proc结构体"></p>
<h1 id="从服务端addService触发的binder-transaction"><a href="#从服务端addService触发的binder-transaction" class="headerlink" title="从服务端addService触发的binder_transaction(...)"></a>从服务端addService触发的<code>binder_transaction(...)</code></h1><p>从native层的调用过程参见<a href="http://palanceli.github.io/blog/2016/05/28/2016/0528BinderLearning10/">binder学习笔记（十）—— 穿越到驱动层</a>。我们以addService为例深入到binder_transaction(…)内部，<br>传入的<code>binder_transaction_data</code>输入参数为：<img src="http://palanceli.github.io/blog/2016/05/11/2016/0514BinderLearning6/img02.png" alt="addService组织的请求数据"></p>
<p>kernel/goldfish/drivers/staging/android/binder.c:1402<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">binder_transaction</span><span class="params">(<span class="keyword">struct</span> binder_proc *proc,</span><br><span class="line">                   <span class="keyword">struct</span> binder_thread *thread,</span><br><span class="line">                   <span class="keyword">struct</span> binder_transaction_data *tr, <span class="keyword">int</span> reply)</span></span><br><span class="line"></span>&#123;   <span class="comment">// reply=(cmd==BC_REPLY)即false，flags=TF_ACCEPT_FDS</span></span><br><span class="line">    <span class="keyword">struct</span> binder_transaction *t;</span><br><span class="line">    <span class="keyword">struct</span> binder_work *tcomplete;</span><br><span class="line">    <span class="keyword">size_t</span> *offp, *off_end;</span><br><span class="line">    <span class="keyword">struct</span> binder_proc *target_proc;</span><br><span class="line">    <span class="keyword">struct</span> binder_thread *target_thread = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">struct</span> binder_node *target_node = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">struct</span> list_head *target_list;</span><br><span class="line">    <span class="keyword">wait_queue_head_t</span> *target_wait;</span><br><span class="line">    <span class="keyword">struct</span> binder_transaction *in_reply_to = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">struct</span> binder_transaction_log_entry *e;</span><br><span class="line">    <span class="keyword">uint32_t</span> return_error;</span><br><span class="line"></span><br><span class="line">    ......</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (reply) &#123;</span><br><span class="line">        ......</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (tr-&gt;target.handle) &#123;  <span class="comment">// tr-&gt;target.handle=0</span></span><br><span class="line">            ......</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            target_node = binder_context_mgr_node; <span class="comment">// service manager对应的节点</span></span><br><span class="line">            ......</span><br><span class="line">        &#125;</span><br><span class="line">        ......</span><br><span class="line">        target_proc = target_node-&gt;proc; <span class="comment">// 得到目标进程的binder_proc</span></span><br><span class="line">        ......</span><br><span class="line">        <span class="comment">// 得到目标线程tr-&gt;flags=TF_ACCEPT_FDS</span></span><br><span class="line">        <span class="comment">// thread未被操作过，故transaction_stack为0</span></span><br><span class="line">        <span class="keyword">if</span> (!(tr-&gt;flags &amp; TF_ONE_WAY) &amp;&amp; thread-&gt;transaction_stack) &#123;</span><br><span class="line">            <span class="keyword">struct</span> binder_transaction *tmp;</span><br><span class="line">            tmp = thread-&gt;transaction_stack;</span><br><span class="line">            ... ...</span><br><span class="line">            <span class="keyword">while</span> (tmp) &#123;</span><br><span class="line">                <span class="keyword">if</span> (tmp-&gt;from &amp;&amp; tmp-&gt;from-&gt;proc == target_proc)</span><br><span class="line">                    target_thread = tmp-&gt;from;</span><br><span class="line">                tmp = tmp-&gt;from_parent;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (target_thread) &#123;</span><br><span class="line">        e-&gt;to_thread = target_thread-&gt;pid;</span><br><span class="line">        target_list = &amp;target_thread-&gt;todo;</span><br><span class="line">        target_wait = &amp;target_thread-&gt;wait;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123; <span class="comment">// 走这里</span></span><br><span class="line">        target_list = &amp;target_proc-&gt;todo;</span><br><span class="line">        target_wait = &amp;target_proc-&gt;wait;</span><br><span class="line">    &#125;</span><br><span class="line">    ......</span><br><span class="line">    t = kzalloc(sizeof(*t), GFP_KERNEL);  <span class="comment">// 创建binder_transaction节点</span></span><br><span class="line">    ......</span><br><span class="line">    tcomplete = kzalloc(sizeof(*tcomplete), GFP_KERNEL);<span class="comment">//创建一个binder_work节点</span></span><br><span class="line">    ......</span><br><span class="line">    <span class="comment">// 这里岂不是为真？thread来自binder_ioctl(...)中的binder_get_thread(proc)</span></span><br><span class="line">    <span class="comment">// 返回proc的当前线程</span></span><br><span class="line">    <span class="keyword">if</span> (!reply &amp;&amp; !(tr-&gt;flags &amp; TF_ONE_WAY)) </span><br><span class="line">        t-&gt;from = thread;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        t-&gt;from = <span class="literal">NULL</span>;</span><br><span class="line">    t-&gt;sender_euid = proc-&gt;tsk-&gt;cred-&gt;euid; <span class="comment">// 源线程用户id</span></span><br><span class="line">    t-&gt;to_proc = target_proc;               <span class="comment">// 负责处理该事务的进程，sm</span></span><br><span class="line">    t-&gt;to_thread = target_thread;           <span class="comment">// 负责处理该事务的线程</span></span><br><span class="line">    t-&gt;code = tr-&gt;code;                     <span class="comment">// ADD_SERVICE_TRANSACTION</span></span><br><span class="line">    t-&gt;flags = tr-&gt;flags;                   <span class="comment">// TF_ACCEPT_FDS</span></span><br><span class="line">    t-&gt;priority = task_nice(current);       <span class="comment">// 源线程优先级</span></span><br><span class="line">    ... ...</span><br><span class="line">    t-&gt;buffer = binder_alloc_buf(target_proc, tr-&gt;data_size,</span><br><span class="line">        tr-&gt;offsets_size, !reply &amp;&amp; (t-&gt;flags &amp; TF_ONE_WAY));</span><br><span class="line">    ......</span><br><span class="line">    t-&gt;buffer-&gt;allow_user_free = <span class="number">0</span>;<span class="comment">// Service处理完该事务后，驱动不会释放该内核缓冲区</span></span><br><span class="line">    t-&gt;buffer-&gt;debug_id = t-&gt;debug_id;</span><br><span class="line">    t-&gt;buffer-&gt;transaction = t; <span class="comment">// 缓冲区正交给哪个事务使用</span></span><br><span class="line">    t-&gt;buffer-&gt;target_node = target_node;   <span class="comment">// 缓冲区正交给哪个Binder实体对象使用</span></span><br><span class="line">    ......</span><br><span class="line">    <span class="keyword">if</span> (target_node)</span><br><span class="line">        binder_inc_node(target_node, <span class="number">1</span>, <span class="number">0</span>, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="comment">// 分析所传数据中的所有binder对象，如果是binder实体，在红黑树中添加相应的节点。</span></span><br><span class="line">    <span class="comment">// 首先，从用户态获取所传输的数据，以及数据里的binder对象偏移信息。</span></span><br><span class="line">    offp = (<span class="keyword">size_t</span> *)(t-&gt;buffer-&gt;data + ALIGN(tr-&gt;data_size, sizeof(void *)));</span><br><span class="line">    <span class="comment">// 将服务端传来的Parcel的数据部分拷贝到内核空间</span></span><br><span class="line">    <span class="keyword">if</span> (copy_from_user(t-&gt;buffer-&gt;data, tr-&gt;data.ptr.buffer, tr-&gt;data_size)) &#123;</span><br><span class="line">        ......</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 将服务端传来的Parcel的偏移数组拷贝到内核空间</span></span><br><span class="line">    <span class="keyword">if</span> (copy_from_user(offp, tr-&gt;data.ptr.offsets, tr-&gt;offsets_size)) &#123;</span><br><span class="line">        ......</span><br><span class="line">    &#125;</span><br><span class="line">    ......</span><br><span class="line">    off_end = (void *)offp + tr-&gt;offsets_size;</span><br><span class="line">    <span class="comment">// 遍历每个flat_binder_object信息，创建必要的红黑树节点</span></span><br><span class="line">    <span class="keyword">for</span> (; offp &lt; off_end; offp++) &#123;</span><br><span class="line">        <span class="keyword">struct</span> flat_binder_object *fp;</span><br><span class="line">        ......</span><br><span class="line">        fp = (struct flat_binder_object *)(t-&gt;buffer-&gt;data + *offp);</span><br><span class="line">        <span class="keyword">switch</span> (fp-&gt;type) &#123;</span><br><span class="line">        <span class="keyword">case</span> BINDER_TYPE_BINDER:</span><br><span class="line">        <span class="keyword">case</span> BINDER_TYPE_WEAK_BINDER: &#123; <span class="comment">// 如果是binder实体</span></span><br><span class="line">            <span class="keyword">struct</span> binder_ref *ref;</span><br><span class="line">            <span class="comment">// fp-&gt;binder是BnTestService::getWeakRefs()，BnTestService的影子对象</span></span><br><span class="line">            <span class="comment">// binder_get_node(...)在proc-&gt;nodes.rb_node中找fp-&gt;binder，如果没有</span></span><br><span class="line">            <span class="comment">// 找到，则在该红黑树中为fp-&gt;binder创建节点</span></span><br><span class="line">            <span class="keyword">struct</span> binder_node *node = binder_get_node(proc, fp-&gt;binder);</span><br><span class="line">            <span class="keyword">if</span> (node == <span class="literal">NULL</span>) &#123;</span><br><span class="line">                node = binder_new_node(proc, fp-&gt;binder, fp-&gt;cookie);</span><br><span class="line">                ......</span><br><span class="line">                node-&gt;min_priority = fp-&gt;flags &amp; FLAT_BINDER_FLAG_PRIORITY_MASK;</span><br><span class="line">                node-&gt;accept_fds = !!(fp-&gt;flags &amp; FLAT_BINDER_FLAG_ACCEPTS_FDS);</span><br><span class="line">            &#125;</span><br><span class="line">            ......</span><br><span class="line">            <span class="comment">// 必要时，会在目标进程的binder_proc中创建对应的binder_ref红黑树节点</span></span><br><span class="line">            ref = binder_get_ref_for_node(target_proc, node);</span><br><span class="line">            ......</span><br><span class="line">            <span class="keyword">if</span> (fp-&gt;type == BINDER_TYPE_BINDER)</span><br><span class="line">                fp-&gt;type = BINDER_TYPE_HANDLE;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                fp-&gt;type = BINDER_TYPE_WEAK_HANDLE;</span><br><span class="line">            <span class="comment">// 修改所传数据中的flat_binder_object信息，因为远端的binder实体到</span></span><br><span class="line">            <span class="comment">// 了目标端就变为binder代理了，所以要记录下binder句柄了。</span></span><br><span class="line">            fp-&gt;handle = ref-&gt;desc;</span><br><span class="line">            binder_inc_ref(ref, fp-&gt;type == BINDER_TYPE_HANDLE,</span><br><span class="line">                       &amp;thread-&gt;todo);</span><br><span class="line">            ......</span><br><span class="line">        &#125; <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> BINDER_TYPE_HANDLE:</span><br><span class="line">        <span class="keyword">case</span> BINDER_TYPE_WEAK_HANDLE: &#123; </span><br><span class="line">            <span class="comment">// 对flat_binder_object做必要的修改，比如将BINDER_TYPE_HANDLE改为</span></span><br><span class="line">            <span class="comment">// BINDER_TYPE_BINDER</span></span><br><span class="line">            <span class="keyword">struct</span> binder_ref *ref = binder_get_ref(proc, fp-&gt;handle);</span><br><span class="line">            ......</span><br><span class="line">            <span class="keyword">if</span> (ref-&gt;node-&gt;proc == target_proc) &#123;</span><br><span class="line">                <span class="keyword">if</span> (fp-&gt;type == BINDER_TYPE_HANDLE)</span><br><span class="line">                    fp-&gt;type = BINDER_TYPE_BINDER;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    fp-&gt;type = BINDER_TYPE_WEAK_BINDER;</span><br><span class="line">                fp-&gt;binder = ref-&gt;node-&gt;ptr;</span><br><span class="line">                fp-&gt;cookie = ref-&gt;node-&gt;cookie;</span><br><span class="line">                binder_inc_node(ref-&gt;node, fp-&gt;type == BINDER_TYPE_BINDER, <span class="number">0</span>, <span class="literal">NULL</span>);</span><br><span class="line">                trace_binder_transaction_ref_to_node(t, ref);</span><br><span class="line">                ... ...</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">struct</span> binder_ref *new_ref;</span><br><span class="line">                new_ref = binder_get_ref_for_node(target_proc, ref-&gt;node);</span><br><span class="line">                <span class="keyword">if</span> (new_ref == <span class="literal">NULL</span>) &#123;</span><br><span class="line">                    return_error = BR_FAILED_REPLY;</span><br><span class="line">                    <span class="keyword">goto</span> err_binder_get_ref_for_node_failed;</span><br><span class="line">                &#125;</span><br><span class="line">                fp-&gt;handle = new_ref-&gt;desc;</span><br><span class="line">                binder_inc_ref(new_ref, fp-&gt;type == BINDER_TYPE_HANDLE, <span class="literal">NULL</span>);</span><br><span class="line">                trace_binder_transaction_ref_to_ref(t, ref,</span><br><span class="line">                                    new_ref);</span><br><span class="line">                ... ...</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">case</span> BINDER_TYPE_FD: &#123;</span><br><span class="line">            <span class="keyword">int</span> target_fd;</span><br><span class="line">            <span class="keyword">struct</span> file *file;</span><br><span class="line">            ... ...</span><br><span class="line"></span><br><span class="line">            file = fget(fp-&gt;handle);</span><br><span class="line">            ... ...</span><br><span class="line">            target_fd = task_get_unused_fd_flags(target_proc, O_CLOEXEC);</span><br><span class="line">            ... ...</span><br><span class="line">            task_fd_install(target_proc, target_fd, file);</span><br><span class="line">            trace_binder_transaction_fd(t, fp-&gt;handle, target_fd);</span><br><span class="line">            binder_debug(BINDER_DEBUG_TRANSACTION,</span><br><span class="line">                     <span class="string">"        fd %ld -&gt; %d\n"</span>, fp-&gt;handle, target_fd);</span><br><span class="line">            <span class="comment">/* <span class="doctag">TODO:</span> fput? */</span></span><br><span class="line">            fp-&gt;handle = target_fd;</span><br><span class="line">        &#125; <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            ... ...</span><br><span class="line">            return_error = BR_FAILED_REPLY;</span><br><span class="line">            <span class="keyword">goto</span> err_bad_object_type;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (reply) &#123;</span><br><span class="line">        ......</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!(t-&gt;flags &amp; TF_ONE_WAY)) &#123;</span><br><span class="line">        ... ...</span><br><span class="line">        t-&gt;need_reply = <span class="number">1</span>;</span><br><span class="line">        t-&gt;from_parent = thread-&gt;transaction_stack;</span><br><span class="line">        thread-&gt;transaction_stack = t;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        ......</span><br><span class="line">        <span class="keyword">if</span> (target_node-&gt;has_async_transaction) &#123;</span><br><span class="line">            target_list = &amp;target_node-&gt;async_todo;</span><br><span class="line">            target_wait = <span class="literal">NULL</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span></span><br><span class="line">            target_node-&gt;has_async_transaction = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    t-&gt;work.type = BINDER_WORK_TRANSACTION;</span><br><span class="line">    <span class="comment">// 把binder_transaction节点插入target_list（即目标todo队列）</span></span><br><span class="line">    list_add_tail(&amp;t-&gt;work.entry, target_list);</span><br><span class="line">    tcomplete-&gt;type = BINDER_WORK_TRANSACTION_COMPLETE;</span><br><span class="line">    list_add_tail(&amp;tcomplete-&gt;entry, &amp;thread-&gt;todo);</span><br><span class="line">    <span class="keyword">if</span> (target_wait) <span class="comment">// 传输动作完毕，现在可以唤醒系统中其它相关线程，wake up!</span></span><br><span class="line">        wake_up_interruptible(target_wait);</span><br><span class="line">    return;</span><br><span class="line"></span><br><span class="line">err_get_unused_fd_failed:</span><br><span class="line">err_fget_failed:</span><br><span class="line">err_fd_not_allowed:</span><br><span class="line">err_binder_get_ref_for_node_failed:</span><br><span class="line">err_binder_get_ref_failed:</span><br><span class="line">err_binder_new_node_failed:</span><br><span class="line">err_bad_object_type:</span><br><span class="line">err_bad_offset:</span><br><span class="line">err_copy_data_failed:</span><br><span class="line">    trace_binder_transaction_failed_buffer_release(t-&gt;buffer);</span><br><span class="line">    binder_transaction_buffer_release(target_proc, t-&gt;buffer, offp);</span><br><span class="line">    t-&gt;buffer-&gt;transaction = <span class="literal">NULL</span>;</span><br><span class="line">    binder_free_buf(target_proc, t-&gt;buffer);</span><br><span class="line">err_binder_alloc_buf_failed:</span><br><span class="line">    kfree(tcomplete);</span><br><span class="line">    binder_stats_deleted(BINDER_STAT_TRANSACTION_COMPLETE);</span><br><span class="line">err_alloc_tcomplete_failed:</span><br><span class="line">    kfree(t);</span><br><span class="line">    binder_stats_deleted(BINDER_STAT_TRANSACTION);</span><br><span class="line">err_alloc_t_failed:</span><br><span class="line">err_bad_call_stack:</span><br><span class="line">err_empty_call_stack:</span><br><span class="line">err_dead_binder:</span><br><span class="line">err_invalid_target_handle:</span><br><span class="line">err_no_context_mgr_node:</span><br><span class="line">    binder_debug(BINDER_DEBUG_FAILED_TRANSACTION,</span><br><span class="line">             <span class="string">"binder: %d:%d transaction failed %d, size %zd-%zd\n"</span>,</span><br><span class="line">             proc-&gt;pid, thread-&gt;pid, return_error,</span><br><span class="line">             tr-&gt;data_size, tr-&gt;offsets_size);</span><br><span class="line"></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">struct</span> binder_transaction_log_entry *fe;</span><br><span class="line">        fe = binder_transaction_log_add(&amp;binder_transaction_log_failed);</span><br><span class="line">        *fe = *e;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    BUG_ON(thread-&gt;return_error != BR_OK);</span><br><span class="line">    <span class="keyword">if</span> (in_reply_to) &#123;</span><br><span class="line">        thread-&gt;return_error = BR_TRANSACTION_COMPLETE;</span><br><span class="line">        binder_send_failed_reply(in_reply_to, return_error);</span><br><span class="line">    &#125; <span class="keyword">else</span></span><br><span class="line">        thread-&gt;return_error = return_error;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="struct-binder-transaction"><a href="#struct-binder-transaction" class="headerlink" title="struct binder_transaction"></a>struct binder_transaction</h2><p>在函数binder_transaction(…)第53行创建了结构体binder_transaction，该结构体用来描述进程间通信过程，即事务。其定义在kernel/goldfish/drivers/staging/android/binder.c:346<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> binder_transaction &#123;</span><br><span class="line">    <span class="keyword">int</span> debug_id;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 当驱动为目标进程或线程创建一个事务时，就会将该成员的type置为</span></span><br><span class="line">    <span class="comment">// BINDER_WORK_TRANSACTION，并将它添加到目标进程或线程的todo队列，等待处理</span></span><br><span class="line">    <span class="keyword">struct</span> binder_work work;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">struct</span> binder_thread *from;         <span class="comment">// 发起事务的线程</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 事务所依赖的另外一个事务以及目标线程下一个要处理的事务</span></span><br><span class="line">    <span class="keyword">struct</span> binder_transaction *from_parent; </span><br><span class="line"></span><br><span class="line">    <span class="keyword">struct</span> binder_proc *to_proc;        <span class="comment">// 负责处理该事务的进程</span></span><br><span class="line">    <span class="keyword">struct</span> binder_thread *to_thread;    <span class="comment">// 负责处理该事务的线程</span></span><br><span class="line">    <span class="keyword">struct</span> binder_transaction *to_parent;</span><br><span class="line">    <span class="keyword">unsigned</span> need_reply:<span class="number">1</span>;              <span class="comment">// 同步事务为1需要等待对方回复；异步为0</span></span><br><span class="line">    <span class="comment">/* unsigned is_dead:1; */</span>   <span class="comment">/* not used at the moment */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 指向驱动为该事务分配的内核缓冲区，保存了进程间通信数据</span></span><br><span class="line">    <span class="keyword">struct</span> binder_buffer *buffer;   </span><br><span class="line"></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span>    code;   <span class="comment">// 直接从进程间通信数据中拷贝过来</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span>    flags;  <span class="comment">// 直接从进程间通信数据中拷贝过来</span></span><br><span class="line">    <span class="keyword">long</span>    priority;       <span class="comment">// 源线程优先级</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 线程在处理事务时，驱动会修改它的优先级以满足源线程和目标Service组建的要求。在修改之</span></span><br><span class="line">    <span class="comment">// 前，会将它原来的线程优先级保存在该成员中，以便线程处理完该事务后可以恢复原来的优先级</span></span><br><span class="line">    <span class="keyword">long</span>    saved_priority; </span><br><span class="line">    <span class="keyword">uid_t</span>   sender_euid;    <span class="comment">// 源线程用户ID</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h2 id="struct-binder-work"><a href="#struct-binder-work" class="headerlink" title="struct binder_work"></a>struct binder_work</h2><p>在binder_transaction(…)第55行创建了struct binder_work，该结构体用于描述待处理的工作项，其定义在kernel/goldfish/drivers/staging/android/binder.c:205<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> binder_work &#123;        </span><br><span class="line">    <span class="keyword">struct</span> list_head entry; <span class="comment">// 用来将该结构体嵌入到一个宿主结构中</span></span><br><span class="line">    <span class="comment">// 描述工作项的类型，根据取值，Binder驱动程序就可以判断出一个binder_work结构体嵌入到</span></span><br><span class="line">    <span class="comment">// 什么类型的宿主结构中</span></span><br><span class="line">    <span class="keyword">enum</span> &#123;</span><br><span class="line">        BINDER_WORK_TRANSACTION = <span class="number">1</span>,</span><br><span class="line">        BINDER_WORK_TRANSACTION_COMPLETE,</span><br><span class="line">        BINDER_WORK_NODE,</span><br><span class="line">        BINDER_WORK_DEAD_BINDER,</span><br><span class="line">        BINDER_WORK_DEAD_BINDER_AND_CLEAR,</span><br><span class="line">        BINDER_WORK_CLEAR_DEATH_NOTIFICATION,</span><br><span class="line">    &#125; type;             </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>到binder_transaction(…)第92行为止，它构造的数据结构如下。此时用户控件的部分数据被拷贝到了内核空间，内核空间中binder_transaction的buffer是从proc-&gt;free_buffers中摘取下来的，为了避免图片过大，此处的细节暂不展现了。摘取下的buffer的数据部分用于暂存从用户空间拷贝来的数据。<br><img src="img11.png" alt="到binder_transaction(...)第92行位置，构造的数据结构"></p>
<h2 id="struct-binder-node"><a href="#struct-binder-node" class="headerlink" title="struct binder_node"></a>struct binder_node</h2><p>从94行开始，逐个遍历t-&gt;buffer.data中的binder objects，在for循环中，fp指向当前的binder object。如果fp-&gt;type是BINDER_TYPE_BINDER或BINDER_TYPE_WEAK_BINDER，#104先从proc-&gt;nodes.rb_node中查找有没有fp-&gt;binder，如果没有则调用binder_new_node(…)在proc-&gt;nodes.rb_node中创建此节点。接下来先看看<code>struct binder_node</code>，kernel/goldfish/drivers/staging/android/binder.c:217，它用来描述一个Binder实体对象，每一个Service组件在驱动层都对应一个binder_node，用来描述在内核中的状态：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> binder_node &#123;            </span><br><span class="line">    <span class="keyword">int</span> debug_id;               <span class="comment">// 帮助调试用的</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 当Binder实体对象的引用计数由0变为1或由1变为0时，Binder驱动程序就会请求相应的</span></span><br><span class="line">    <span class="comment">// Service组件增加或减少其引用计数。Binder驱动程序就会将“该引用计数修改”封装成一个类</span></span><br><span class="line">    <span class="comment">// 型为一个类型为binder_node的工作项，即将成员work的值置为BINDER_WORK_NODE，并将</span></span><br><span class="line">    <span class="comment">// 它添加到相应进程的todo队列中等待处理</span></span><br><span class="line">    <span class="keyword">struct</span> binder_work work;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">union</span> &#123;</span><br><span class="line">        <span class="keyword">struct</span> rb_node rb_node;</span><br><span class="line">        <span class="keyword">struct</span> hlist_node dead_node;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 指向宿主进程，宿主进程使用一个红黑树来维护它内部所有Binder实体对象，而每一个</span></span><br><span class="line">    <span class="comment">// Binder实体对象的成员变量rb_node就正好是这个红黑树的一个节点。如果Binder实体对象</span></span><br><span class="line">    <span class="comment">// 的宿主进程已经死亡，那么该Binder实体对象就会通过它的成员变量dead_node保存在一个全</span></span><br><span class="line">    <span class="comment">// 局的hash列表中。</span></span><br><span class="line">    <span class="keyword">struct</span> binder_proc *proc;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 一个Binder实体对象可能会同时被多个Client组件引用，因此Binder驱动使用结构体</span></span><br><span class="line">    <span class="comment">// binder_ref来描述这些引用关系，并且将引用了同一个Binder实体对象的所有引用都保存在</span></span><br><span class="line">    <span class="comment">// 一个hash列表中。这个hash列表通过Binder实体对象的refs成员来描述，而Binder驱动通</span></span><br><span class="line">    <span class="comment">// 过refs就可以知道有哪些Client组件引用了同一个Binder实体对象</span></span><br><span class="line">    <span class="keyword">struct</span> hlist_head refs;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> internal_strong_refs;       <span class="comment">// 描述Bidner实体对象的强引用计数</span></span><br><span class="line">    <span class="keyword">int</span> local_weak_refs;            <span class="comment">// 描述Binder实体对象的弱引用计数</span></span><br><span class="line">    <span class="keyword">int</span> local_strong_refs;          <span class="comment">// 描述Bidner实体对象的强引用计数</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span> __user *ptr;       <span class="comment">// 描述用户空间中的Service组件，指向Service的影子对象</span></span><br><span class="line">    <span class="keyword">void</span> __user *cookie;    <span class="comment">// 描述用户空间中的Service组件的地址，指向Service的地址</span></span><br><span class="line"></span><br><span class="line">     <span class="comment">// 当Binder实体对象请求Service执行某个操作时，会增加该Service的强/弱引用计数，</span></span><br><span class="line">     <span class="comment">// has_strong_ref和has_weak_ref被置1；</span></span><br><span class="line">     <span class="comment">// 当Service完成Binder所请求的操作后，会递减该Service的强/弱引用计数，has_strong_ref和has_weak_ref被置0；</span></span><br><span class="line">     <span class="comment">// Binder实体在请求Service增/减强/弱引用计数的过程中，会将</span></span><br><span class="line">     <span class="comment">// pending_strong_ref或pending_weak_ref置1；</span></span><br><span class="line">     <span class="comment">// 当Service完成增/减强/弱引用计数之后，会将这两个成员变量置为0。</span></span><br><span class="line">    <span class="keyword">unsigned</span> has_strong_ref:<span class="number">1</span>;     </span><br><span class="line">    <span class="keyword">unsigned</span> pending_strong_ref:<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">unsigned</span> has_weak_ref:<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">unsigned</span> pending_weak_ref:<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 描述Binder对象是否正在处理一个异步事务。Binder驱动程序将一个事务保存在todo队列中</span></span><br><span class="line">    <span class="comment">// 表示将由该线程来处理该事务。每个事务都关联着一个Binder实体对象，要求与该Binder实</span></span><br><span class="line">    <span class="comment">// 体对象对应的Service组件在指定线程中处理该事务。然而，当Binder驱动发现一个事务是异</span></span><br><span class="line">    <span class="comment">// 步事务时，就会将它保存在目标Binder实体对象的一个异步事务队列中，这个异步事务队列就</span></span><br><span class="line">    <span class="comment">// 是由成员变量async_todo来描述的。异步事务的定义是那些单向的进程间通信请求，即不需</span></span><br><span class="line">    <span class="comment">// 要等待应答的进程间通信请求，与此相对的是同步事务。因为不需要等待应答，Binder驱动就</span></span><br><span class="line">    <span class="comment">// 认为异步事务优先级低于同步事务，具体表现为在同一时刻，一个Binder实体对象的所有异步</span></span><br><span class="line">    <span class="comment">// 事务最多只有一个会得到处理，其余的都等待在异步事务队列中，而同步事务无此限制。</span></span><br><span class="line">    <span class="keyword">unsigned</span> has_async_transaction:<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 描述Binder实体对象是否可以接收包含有文件描述符的进程间通信数据。1表示可以接收，0表</span></span><br><span class="line">    <span class="comment">// 示禁止接收。当一个进程向另一个进程发送的数据中包含有文件描述符时，Binder驱动程序就</span></span><br><span class="line">    <span class="comment">// 会自动在目标进程中打开一个相同的文件。基于安全性考虑，Binder程序就要通过该变量防止</span></span><br><span class="line">    <span class="comment">// 源进程在目标进程中打开文件。</span></span><br><span class="line">    <span class="keyword">unsigned</span> accept_fds:<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 表示Binder实体对象在处理来自Client进程的请求时，他所要求的处理线程（即Server进程</span></span><br><span class="line">    <span class="comment">// 中的一个线程）应具备的最小线程优先级。</span></span><br><span class="line">    <span class="keyword">unsigned</span> min_priority:<span class="number">8</span>;       </span><br><span class="line">    <span class="keyword">struct</span> list_head async_todo;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>接下来的binder_new_node(proc, fp-&gt;binder, fp-&gt;cookie)将申请一个<code>struct binder_node</code>，在初始化中，将该节点挂到proc-&gt;nodes.rb_node中，并初始化部分成员，数据结构图如下：<br><img src="img12.png" alt="在case BINDER_TYPE_BINDER和case BINDER_TYPE_WEAK_BINDER中创建的struct binder_node"></p>
<h2 id="struct-binder-ref"><a href="#struct-binder-ref" class="headerlink" title="struct binder_ref"></a>struct binder_ref</h2><p>struct binder_ref用来描述一个Binder引用对象，当客户端使用Binder实体时，在客户端保存的就是对该实体的引用，该结构体用来描述引用对象在内核中的状态。kernel/goldfish/drivers/staging/android/binder.c:246<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> binder_ref &#123;</span><br><span class="line">    <span class="comment">/* Lookups needed: */</span></span><br><span class="line">    <span class="comment">/*   node + proc =&gt; ref (transaction) */</span></span><br><span class="line">    <span class="comment">/*   desc + proc =&gt; ref (transaction, inc/dec ref) */</span></span><br><span class="line">    <span class="comment">/*   node =&gt; refs + procs (proc exit) */</span></span><br><span class="line">    <span class="keyword">int</span> debug_id;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 宿主进程使用两个红黑树来保存它内部所有Binder引用对象，分别以句柄值和对应的Binder</span></span><br><span class="line">    <span class="comment">// 实体对象地址来作为关键字保存这些引用对象，这两个rb_node_xxxx正是红黑树中的节点</span></span><br><span class="line">    <span class="keyword">struct</span> rb_node rb_node_desc;    </span><br><span class="line">    <span class="keyword">struct</span> rb_node rb_node_node;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 每个Binder实体对象都有一个hash表保存引用了它的Binder引用对象，这些引用对象的成员</span></span><br><span class="line">    <span class="comment">// node_entry就是该hash表的节点</span></span><br><span class="line">    <span class="keyword">struct</span> hlist_node node_entry;   </span><br><span class="line">    <span class="keyword">struct</span> binder_proc *proc;   <span class="comment">// 宿主进程</span></span><br><span class="line">    <span class="keyword">struct</span> binder_node *node;   <span class="comment">// 描述Binder引用对象所引用的Binder实体对象</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 描述Binder引用对象的句柄值，驱动通过该句柄找到对应的Binder引用对象，然后再根据该</span></span><br><span class="line">    <span class="comment">// Binder引用对象的成员node找到对应的Binder实体对象，然后就可以通过该实体对象找到要</span></span><br><span class="line">    <span class="comment">// 访问的Service组件了。一个Binder引用对象的句柄值仅在进程范围内唯一，因此在两个不同</span></span><br><span class="line">    <span class="comment">// 进程中，同一个句柄可能代表不同的Service组件</span></span><br><span class="line">    <span class="keyword">uint32_t</span> desc;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> strong;                 <span class="comment">// 描述Binder引用对象的强/弱引用计数</span></span><br><span class="line">    <span class="keyword">int</span> weak;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 指向一个Service组件的死亡接收通知。当Client进程向Binder驱动程序注册一个它所引用</span></span><br><span class="line">    <span class="comment">// 的Service组件死亡接收通知时，Binder驱动程序会创建一个binder_ref_death结构体，然</span></span><br><span class="line">    <span class="comment">// 后保存在该成员变量death中</span></span><br><span class="line">    <span class="keyword">struct</span> binder_ref_death *death; </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>接下来看binder_get_ref_for_node(target_proc, node)。需要注意，前面创建binder_node的时候，是为proc创建的，proc是在调用binder_open(…)时创建，用来描述“使用（打开）该binder的进程”，proc就藏在binder文件的文件描述符的私有数据中；而此处（第150行）参数使用的是target_proc，它表示当前的binder请求发向的目标进程，在本上下文中就是handle为0的service manager，即binder_context_mgr_node。<br>kernel/goldfish/drivers/staging/android/binder.c:1107<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">struct</span> binder_ref *<span class="title">binder_get_ref_for_node</span><span class="params">(<span class="keyword">struct</span> binder_proc *proc,</span><br><span class="line">                          <span class="keyword">struct</span> binder_node *node)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    <span class="keyword">struct</span> rb_node *n;</span><br><span class="line">    <span class="keyword">struct</span> rb_node **p = &amp;proc-&gt;refs_by_node.rb_node;</span><br><span class="line">    <span class="keyword">struct</span> rb_node *parent = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">struct</span> binder_ref *ref, *new_ref;</span><br><span class="line">    <span class="comment">// 在target_proc中查找node，如果找不到就创建</span></span><br><span class="line">    <span class="keyword">while</span> (*p) &#123;</span><br><span class="line">        parent = *p;</span><br><span class="line">        ref = rb_entry(parent, struct binder_ref, rb_node_node);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (node &lt; ref-&gt;node)</span><br><span class="line">            p = &amp;(*p)-&gt;rb_left;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (node &gt; ref-&gt;node)</span><br><span class="line">            p = &amp;(*p)-&gt;rb_right;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            return ref;</span><br><span class="line">    &#125;</span><br><span class="line">    new_ref = kzalloc(sizeof(*ref), GFP_KERNEL);</span><br><span class="line">    ... ...</span><br><span class="line">    binder_stats_created(BINDER_STAT_REF);</span><br><span class="line">    new_ref-&gt;debug_id = ++binder_last_id;</span><br><span class="line">    new_ref-&gt;proc = proc;</span><br><span class="line">    new_ref-&gt;node = node;</span><br><span class="line">    rb_link_node(&amp;new_ref-&gt;rb_node_node, parent, p);</span><br><span class="line">    rb_insert_color(&amp;new_ref-&gt;rb_node_node, &amp;proc-&gt;refs_by_node);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 遍历target_proc的binder_ref，找到最大的desc，加1后赋给new_ref-&gt;desc</span></span><br><span class="line">    new_ref-&gt;desc = (node == binder_context_mgr_node) ? <span class="number">0</span> : <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (n = rb_first(&amp;proc-&gt;refs_by_desc); n != <span class="literal">NULL</span>; n = rb_next(n)) &#123;</span><br><span class="line">        ref = rb_entry(n, struct binder_ref, rb_node_desc);</span><br><span class="line">        <span class="keyword">if</span> (ref-&gt;desc &gt; new_ref-&gt;desc)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        new_ref-&gt;desc = ref-&gt;desc + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将new_ref插入到target_proc-&gt;refs_by_desc.rb_node中</span></span><br><span class="line">    p = &amp;proc-&gt;refs_by_desc.rb_node;</span><br><span class="line">    <span class="keyword">while</span> (*p) &#123;</span><br><span class="line">        parent = *p;</span><br><span class="line">        ref = rb_entry(parent, struct binder_ref, rb_node_desc);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (new_ref-&gt;desc &lt; ref-&gt;desc)</span><br><span class="line">            p = &amp;(*p)-&gt;rb_left;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (new_ref-&gt;desc &gt; ref-&gt;desc)</span><br><span class="line">            p = &amp;(*p)-&gt;rb_right;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            BUG();</span><br><span class="line">    &#125;</span><br><span class="line">    rb_link_node(&amp;new_ref-&gt;rb_node_desc, parent, p);</span><br><span class="line">    rb_insert_color(&amp;new_ref-&gt;rb_node_desc, &amp;proc-&gt;refs_by_desc);</span><br><span class="line">    <span class="keyword">if</span> (node) &#123;</span><br><span class="line">        hlist_add_head(&amp;new_ref-&gt;node_entry, &amp;node-&gt;refs);</span><br><span class="line">        ... ...</span><br><span class="line">    &#125; </span><br><span class="line">    ... ...</span><br><span class="line">    return new_ref;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>于是，在binder_transaction(…)函数第114行完成调用<code>binder_get_ref_for_node(target_proc, node)</code>之后，数据结构图为：<br><img src="img13.png" alt="在binder_transaction(...)函数中为target_proc创建完binder_ref之后的数据结构"></p>
<p>接下来在函数binder_transaction(…)中还有几个关键操作，见第116行，如果fp-&gt;type为BINDER_TYPE_BINDER，就改为BINDER_TYPE_HANDLE，然后把fp-&gt;handle改为ref-&gt;desc，接下来的binder_ref_ref(ref, fp-&gt;type==BINDER_TYPE_HANDLE, &amp;thread-&gt;todo)定义在kernel/goldfish/drivers/staging/android/binder.c:1200<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">binder_inc_ref</span><span class="params">(<span class="keyword">struct</span> binder_ref *ref, <span class="keyword">int</span> strong,</span><br><span class="line">              <span class="keyword">struct</span> list_head *target_list)</span></span><br><span class="line"></span>&#123;   <span class="comment">// strong = (fp-&gt;type==BINDER_TYPE_HANDLE)即为1</span></span><br><span class="line">    <span class="comment">// target_list = &amp;thread-&gt;todo</span></span><br><span class="line">    <span class="keyword">int</span> ret;</span><br><span class="line">    <span class="keyword">if</span> (strong) &#123;</span><br><span class="line">        <span class="keyword">if</span> (ref-&gt;strong == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// ref-&gt;node-&gt;internal_strong_ref++，成功返回0</span></span><br><span class="line">            ret = binder_inc_node(ref-&gt;node, <span class="number">1</span>, <span class="number">1</span>, target_list);</span><br><span class="line">            <span class="keyword">if</span> (ret)</span><br><span class="line">                return ret;</span><br><span class="line">        &#125;</span><br><span class="line">        ref-&gt;strong++;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (ref-&gt;weak == <span class="number">0</span>) &#123;</span><br><span class="line">            ret = binder_inc_node(ref-&gt;node, <span class="number">0</span>, <span class="number">1</span>, target_list);</span><br><span class="line">            <span class="keyword">if</span> (ret)</span><br><span class="line">                return ret;</span><br><span class="line">        &#125;</span><br><span class="line">        ref-&gt;weak++;</span><br><span class="line">    &#125;</span><br><span class="line">    return <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>接下来跳出case后还有对t的成员need_reply、from_parent、t-&gt;work.type的处理，并将t插入到target_list即target_proc或target_thread的todo队列中，尔后返回。此时的数据结构图为：<br><img src="img14.png" alt="binder_transaction(...)完成时的数据结构"></p>
<p>到此为止，终于完成了binder_transaction(…)的分析，知道怎么回事，但心里有很多个“为什么”。而且把前面的学习笔记串联起来，隐约觉得能感应到一些曙光了，本节的篇幅太长了，这些曙光留待下一节一起领略吧。</p>
</div><script type="text/javascript" src="/blog/js/share.js?v=0.0.0" async></script><a data-url="http://palanceli.github.io/blog/2016/06/14/2016/0614BinderLearning12/" data-id="ciqi8bul8001drlziedfkk6yc" class="article-share-link">分享到</a><div class="tags"><a href="/blog/tags/binder/">binder</a></div><div class="post-nav"><a href="/blog/2016/07/09/2016/0709BinderLearning13/" class="pre">Binder学习笔记（十三）—— 小结</a><a href="/blog/2016/06/10/2016/0610BinderLearning11/" class="next">Binder学习笔记（十一）—— 智能指针</a></div><div id="disqus_thread"><script>var disqus_shortname = 'palance';
var disqus_identifier = '2016/06/14/2016/0614BinderLearning12/';
var disqus_title = 'Binder学习笔记（十二）—— binder_transaction(...)都干了什么？';
var disqus_url = 'http://palanceli.github.io/2016/06/14/2016/0614BinderLearning12/';
(function() {
  var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
  dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
  (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
})();</script><script id="dsq-count-scr" src="//palance.disqus.com/count.js" async></script></div></div></div></div><div class="pure-u-1-4"><div id="sidebar"><div class="widget"><form action="//www.baidu.com/baidu" method="get" accept-charset="utf-8" target="_blank" class="search-form"><input type="search" name="word" maxlength="20" placeholder="Search"/><input type="hidden" name="si" value="http://palanceli.github.io"/><input name="tn" type="hidden" value="bds"/><input name="cl" type="hidden" value="3"/><input name="ct" type="hidden" value="2097152"/><input name="s" type="hidden" value="on"/></form></div><div class="widget"><div class="widget-title"><i class="fa fa-folder-o"> 分类</i></div><ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/blog/categories/Android/">Android</a></li><li class="category-list-item"><a class="category-list-link" href="/blog/categories/环境、配置/">环境、配置</a></li><li class="category-list-item"><a class="category-list-link" href="/blog/categories/生活/">生活</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-star-o"> 标签</i></div><div class="tagcloud"><a href="/blog/tags/binder/" style="font-size: 15px;">binder</a> <a href="/blog/tags/hexo/" style="font-size: 15px;">hexo</a> <a href="/blog/tags/音乐/" style="font-size: 15px;">音乐</a></div></div><div class="widget"><div class="widget-title"><i class="fa fa-file-o"> 最新文章</i></div><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/blog/2016/07/09/2016/0709BinderLearning13/">Binder学习笔记（十三）—— 小结</a></li><li class="post-list-item"><a class="post-list-link" href="/blog/2016/06/14/2016/0614BinderLearning12/">Binder学习笔记（十二）—— binder_transaction(...)都干了什么？</a></li><li class="post-list-item"><a class="post-list-link" href="/blog/2016/06/10/2016/0610BinderLearning11/">Binder学习笔记（十一）—— 智能指针</a></li><li class="post-list-item"><a class="post-list-link" href="/blog/2016/05/28/2016/0528BinderLearning10/">binder学习笔记（十）—— 穿越到驱动层</a></li><li class="post-list-item"><a class="post-list-link" href="/blog/2016/05/21/2016/0521小雨点参加钢琴比赛/">小雨点第一次参加钢琴比赛</a></li><li class="post-list-item"><a class="post-list-link" href="/blog/2016/05/15/2016/0514BinderLearning9/">Binder学习笔记（九）—— 服务端如何响应Test()请求 ？ </a></li><li class="post-list-item"><a class="post-list-link" href="/blog/2016/05/14/2016/0514BinderLearning8/">Binder学习笔记（八）—— 客户端如何组织Test()请求 ？ </a></li><li class="post-list-item"><a class="post-list-link" href="/blog/2016/05/12/2016/0512使用hexo搭建博客并上传GitHub/">使用hexo搭建博客并上传GitHub</a></li><li class="post-list-item"><a class="post-list-link" href="/blog/2016/05/12/2016/0514BinderLearning7/">Binder学习笔记（七）—— ServiceManager如何响应addService请求 ？ </a></li><li class="post-list-item"><a class="post-list-link" href="/blog/2016/05/11/2016/0514BinderLearning6/">Binder学习笔记（六）—— binder服务端是如何组织addService数据的？ </a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-comment-o"> 最近评论</i></div><script type="text/javascript" src="//palance.disqus.com/recent_comments_widget.js?num_items=5&amp;hide_avatars=1&amp;avatar_size=32&amp;excerpt_length=20&amp;hide_mods=1"></script></div><div class="widget"><div class="widget-title"><i class="fa fa-external-link"> 友情链接</i></div><ul></ul><a href="https://github.com/palanceli" title="我的GitHub" target="_blank">我的GitHub</a><ul></ul><a href="http://www.cnblogs.com/palance/" title="我的博客园" target="_blank">我的博客园</a><ul></ul><a href="http://blog.csdn.net/zchongr" title="我的CSDN" target="_blank">我的CSDN</a><ul></ul><a href="http://www.jianshu.com/users/5e527164a8c2" title="我的简书" target="_blank">我的简书</a></div></div></div><div class="pure-u-1 pure-u-md-3-4"><div id="footer">© <a href="/blog/." rel="nofollow">Palance's Blog.</a> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a><a rel="nofollow" target="_blank" href="https://github.com/tufu9441/maupassant-hexo"> Theme</a> by<a rel="nofollow" target="_blank" href="https://github.com/pagecho"> Cho.</a></div></div></div><a id="rocket" href="#top" class="show"></a><script type="text/javascript" src="/blog/js/totop.js?v=0.0.0" async></script><script type="text/javascript" src="//cdn.bootcss.com/fancybox/2.1.5/jquery.fancybox.pack.js" async></script><script type="text/javascript" src="/blog/js/fancybox.js?v=0.0.0" async></script><link rel="stylesheet" type="text/css" href="/blog/css/jquery.fancybox.css?v=0.0.0"><script type="text/javascript" src="/blog/js/codeblock-resizer.js?v=0.0.0"></script><script type="text/javascript" src="/blog/js/smartresize.js?v=0.0.0"></script></div></body></html>