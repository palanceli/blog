<!DOCTYPE html><html lang="zh-CN"><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description"><title>Binder学习笔记（十）—— 智能指针 | Palance's Blog</title><link rel="stylesheet" type="text/css" href="/blog/css/style.css?v=0.0.0"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/normalize/4.1.1/normalize.min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/pure/0.6.0/pure-min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/pure/0.6.0/grids-responsive-min.css"><link rel="stylesheet" href="//cdn.bootcss.com/font-awesome/4.6.2/css/font-awesome.min.css"><script type="text/javascript" src="//cdn.bootcss.com/jquery/2.2.3/jquery.min.js"></script><link rel="Shortcut Icon" type="image/x-icon" href="/blog/favicon.ico"><link rel="apple-touch-icon" href="/blog/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/blog/apple-touch-icon.png"></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">Binder学习笔记（十）—— 智能指针</h1><a id="logo" href="/blog/.">Palance's Blog</a><p class="description"></p></div><div id="nav-menu"><a href="/blog/." class="current"><i class="fa fa-home"> 首页</i></a><a href="/blog/archives/"><i class="fa fa-archive"> 归档</i></a><a href="/blog/about/"><i class="fa fa-user"> 关于</i></a><a href="/blog/atom.xml"><i class="fa fa-rss"> 订阅</i></a></div></div><div id="layout" class="pure-g"><div class="pure-u-1 pure-u-md-3-4"><div class="content_container"><div class="post"><h1 class="post-title">Binder学习笔记（十）—— 智能指针</h1><div class="post-meta">Jun 10, 2016<span> | </span><span class="category"><a href="/blog/categories/Android/">Android</a></span><script src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js" async></script><span id="busuanzi_container_page_pv"> | <span id="busuanzi_value_page_pv"></span><span> Hits</span></span></div><a data-disqus-identifier="2016/06/10/2016/0610BinderLearning11/" href="/blog/2016/06/10/2016/0610BinderLearning11/#disqus_thread" class="disqus-comment-count"></a><div class="clear"><div id="toc" class="toc-article"><div class="toc-title">文章目录</div><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#轻量级指针"><span class="toc-number">1.</span> <span class="toc-text">轻量级指针</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#情景分析"><span class="toc-number">1.1.</span> <span class="toc-text">情景分析</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#强-弱智能指针"><span class="toc-number">2.</span> <span class="toc-text">强/弱智能指针</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#强-弱智能指针的目的"><span class="toc-number">2.1.</span> <span class="toc-text">强/弱智能指针的目的</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#强-弱智能指针的使用"><span class="toc-number">2.2.</span> <span class="toc-text">强/弱智能指针的使用</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#情景分析-1"><span class="toc-number">2.3.</span> <span class="toc-text">情景分析</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#构造sp对象和wp对象"><span class="toc-number">2.3.1.</span> <span class="toc-text">构造sp对象和wp对象</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#RefBase构造函数"><span class="toc-number">2.3.1.1.</span> <span class="toc-text">RefBase构造函数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#sp拷贝构造函数"><span class="toc-number">2.3.1.2.</span> <span class="toc-text">sp拷贝构造函数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#wp拷贝构造函数"><span class="toc-number">2.3.1.3.</span> <span class="toc-text">wp拷贝构造函数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#wp析构函数"><span class="toc-number">2.3.1.4.</span> <span class="toc-text">wp析构函数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#sp析构函数"><span class="toc-number">2.3.1.5.</span> <span class="toc-text">sp析构函数</span></a></li></ol></li></ol></li></ol></li></ol></div></div><div class="post-content"><h1 id="轻量级指针"><a href="#轻量级指针" class="headerlink" title="轻量级指针"></a>轻量级指针</h1><p>Binder的学习历程爬到驱动的半山腰明显感觉越来越陡峭，停下业务层的学习，补补基础层知识吧，这首当其冲的就是智能指针了，智能指针的影子在Android源码中随处可见。打开frameworkds/rs/cpp/util，RefBase.h和StrongPointer.h两个文件，代码多读几遍都能读懂，可是串起来总感觉摸不到骨架，把不住主线。闭上眼零零星星的点串不成一条线。究其原因应该是此处使用了模式，最好先剔除掉业务层的皮肉，把模式的骨架摸个门清，再回来看代码就会势如破竹了。</p>
<p>不是多么高深的设计模式，智能指针和引用计数的混合而已。但，不要轻敌。翻开书，对这两个模式的描述竟有50页之多。我读的是Scott Meyers的《More Effective C++》，侯sir翻译的版本，十年前读这本书的时候囫囵吞枣很多读不懂，有一些概念依稀留下点印象。这些印象就构成了日后遇到问题时的路标，告诉我答案在哪里。这本书条款28、29讲的正是智能指针和引用计数，两章结尾处的代码几乎就是Android源码中LightRefBase和sp的原型。每一个条款都从一个简单的目标入手，不断地解决问题，再升级提出它的不足，再找答案，直到把这个问题打穿打透为止。这两个条款的内容就不赘述了，书里写的更精彩。接下来我把模式和Android源码的智能指针对接起来。</p>
<p>《More Effective C++》第203页，条款29描绘了具有引用计数功能的智能指针模式图如下：<br><img src="img01.png" alt="《More Effective C++》条款29"><br>这张图还是把业务逻辑和模式框架混在一起了：</p>
<ul>
<li>String代表业务逻辑</li>
<li>RCPtr是具备引用计数功能的智能指针</li>
<li>RCObject用来履行引用计数的职责</li>
<li>StringValue和HeapMemory又是局部的业务逻辑了</li>
</ul>
<p>所以该模式本质上是由RCPtr和RCObject联袂完成，RCPtr负责智能指针，RCObject负责引用计数，如下：<br><img src="img02.png" alt="具备引用计数功能得智能指针"><br>一个对象如果要配备引用计数和智能指针，则需要：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> MyClass : <span class="keyword">public</span> RCObject <span class="comment">// 让该对象的类从RCObject派生</span></span><br><span class="line">&#123;...&#125;;</span><br><span class="line">RCPtr&lt;MyClass&gt; pObj; <span class="comment">// 声明对象</span></span><br></pre></td></tr></table></figure></p>
<p>对应到Android源码中，LightRefBase就是RCObject，sp就是RCPtr：<br><img src="img03.png" alt="Android源码中的轻量级智能指针"></p>
<p>我在初读Android源码的时候一直琢磨为什么搞得这么复杂，不能把智能指针封装在一个基类里。如果可以的话，MyClass只需要从这个类派生就好了。答案是不可以。因为RCPtr本质上要充当指针的角色，ptr1可以指向A，也可以指向B，当从A转向了B，应该让A的引用计数递减，让B的引用计数递增，这个计数只能是被指对象的属性，而不能是指针的。</p>
<p>我之所以会有合二为一的年头，是因为过去接触的智能指针大都是为了解决遇到Exception或错误返回时防止内存或资源泄露，又不想使用goto语句，比如：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fun</span><span class="params">(<span class="keyword">char</span> * filename)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    FILE* fp = fopen(filename, <span class="string">"r"</span>);</span><br><span class="line">    <span class="keyword">int</span> result = <span class="number">0</span></span><br><span class="line">    ... ...</span><br><span class="line">    <span class="keyword">if</span>(error)&#123;</span><br><span class="line">        result = <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">goto</span> <span class="built_in">exit</span>;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="built_in">exit</span>:</span><br><span class="line">    fclose(fp);</span><br><span class="line">    return result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>如果在函数中打开了多种资源，则要么记住它们的状态，在exit中根据状态擦屁股；要么就得有多个goto标记。此时就可以使用智能指针的思想，给文件做个封装：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">fun</span><span class="params">(<span class="keyword">char</span> * filename)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    MyFile file;  <span class="comment">// MyFile在析构的时候会自动关闭文件</span></span><br><span class="line">    <span class="keyword">if</span>(!file.open(filename, <span class="string">"r"</span>))</span><br><span class="line">        return <span class="number">-1</span>;</span><br><span class="line">    ... ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这一类的智能指针可以看做“具备引用计数的智能指针”的特例，它的引用计数最多为1，且不存在所有权的转移，可以把引用计数RCObject模块退化掉，指针指向资源即代表引用计数为1，不指向任何资源则代表引用计数为0。因此这种情况可以让MyClass仅派生自RCPtr基类即可，一旦引用计数允许大于1，就必须带上RCObject的角色了。</p>
<p>回到Android源码上来，轻量级的智能指针：</p>
<ul>
<li>LightRefBase负责维护引用计数，并提供递增/递减的接口。</li>
<li>sp履行智能指针的角色，负责构造析构、拷贝和赋值、提领。</li>
</ul>
<p>还有一个问题：LightRefBase和《More Effective C++》条款29中的RCObject相比多出一个模板参数，在该类的定义中几乎没有用到这个模板参数，这是为什么？我分析应该是出于性能的考虑——这样做可以省去虚表的开销：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">RCObject::removeReference()</span><br><span class="line">&#123;<span class="keyword">if</span>(--refCount == <span class="number">0</span>) <span class="keyword">delete</span> <span class="keyword">this</span>;&#125;</span><br></pre></td></tr></table></figure></p>
<p>这里要经由基类的指针删除派生类的对象，在《Effecive C++（第三版）》（刚刚发现这本书的第二版和第三版调整很大！）第7条中说到:</p>
<blockquote>
<p>当派生类的对象经由基类指针被删除时，基类必须有虚析构函数，否则会导致未定义的行为，通常是对象的devrived成分没被销毁。</p>
</blockquote>
<p>RCObject确实声明了析构函数为virtual，也因此不得不引入虚表。再看LightRefBase：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> LightRefBase</span><br><span class="line">&#123;</span><br><span class="line">... ...</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">decStrong</span><span class="params">(<span class="keyword">const</span> Void* id)</span> <span class="keyword">const</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(android_atomic_dec(&amp;mCount) == <span class="number">1</span>)&#123;</span><br><span class="line">            <span class="comment">// 这里并没有delete this，而是先转成子类再delete，这就不再是</span></span><br><span class="line">            <span class="comment">// “经由基类指针删除子类对象”，而是“由子类指针删除子类对象”了，</span></span><br><span class="line">            <span class="comment">// 怎么得到子类指针？模板参数T呀！为这段代码拍案叫绝！</span></span><br><span class="line">            <span class="keyword">delete</span> <span class="keyword">static_cast</span>&lt;<span class="keyword">const</span> T*&gt;(<span class="keyword">this</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h2 id="情景分析"><a href="#情景分析" class="headerlink" title="情景分析"></a>情景分析</h2><p>Android智能指针的代码不多，且比较独立，我把它们抽取出来，再写一些测试用例，对这块代码的理解大有裨益。我在Anrdoid源码中每个函数头部都打了Log，标示函数名。代码可以到这里下载<a href="https://github.com/palanceli/androidex/tree/master/host-smartptr" target="_blank" rel="external">androidex/host-smartptr</a>。这里的Android源码取自android-6.0.1_r11。</p>
<ul>
<li>StrongPointer.h<br>来自<code>frameworks/rs/cpp/util/StrongPointer.h</code></li>
<li>RefBase.h<br>来自<code>frameworks/rs/cpp/util/RefBase.h</code></li>
<li>RefBase.cpp<br>来自<code>system/core/libutils/RefBase.cpp</code></li>
<li>meyers.h<br>来自《More Effective C++》条款29，是带有引用计数功能的智能指针的实现</li>
<li>testlightptr.cpp和testweightptr.cpp<br>是对Android轻量级智能指针和强、弱智能指针的测试用例，</li>
<li>logger.h<br>是一个log工具，</li>
<li>smartptr.cpp<br>是主入口函数，该文件包含若干测试用例，函数名为tc01、tc02…</li>
</ul>
<p>该程序的使用方法为：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">smartptr &lt;tcname&gt;</span><br></pre></td></tr></table></figure></p>
<p>例如：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">smartptr tc01  <span class="comment"># 它执行例程函数tc01</span></span><br></pre></td></tr></table></figure></p>
<p>一下是对轻量级指针的测试代码：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="string">"RefBase.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="string">"logger.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> LightClass : <span class="keyword">public</span> LightRefBase &lt;LightClass&gt;</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    LightClass()&#123;&#125;</span><br><span class="line">    ~LightClass()&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">testlightptr</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> <span class="keyword">const</span> * argv[])</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    <span class="comment">// 初始lpLightClass的引用计数为0</span></span><br><span class="line">    LightClass * pLightClass = new LightClass();</span><br><span class="line">    <span class="comment">// 调用sp的复制构造函数sp::sp(T* other)，使得pLightClass的引用计数为1。</span></span><br><span class="line">    sp&lt;LightClass&gt; lpOut = pLightClass;</span><br><span class="line">    Logging(<span class="string">"Light Ref Count: %d."</span>, pLightClass-&gt;getStrongCount());</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 调用sp的赋值构造函数sp::sp(const sp&lt;T&gt;&amp; other)，</span></span><br><span class="line">        <span class="comment">// 使得pLightClass的引用计数累加为2</span></span><br><span class="line">        sp&lt;LightClass&gt; lpInner = lpOut;</span><br><span class="line">        Logging(<span class="string">"Light Ref Count: %d."</span>, pLightClass-&gt;getStrongCount());</span><br><span class="line">        <span class="comment">// lpInner析构，pLightClass的引用计数递减为1</span></span><br><span class="line">    &#125;</span><br><span class="line">    Logging(<span class="string">"Light Ref Count:%d."</span>, pLightClass-&gt;getStrongCount());</span><br><span class="line">    return <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// lpOut析构，pLightClass引用计数递减为0，在decStrong(...)中delete pLightClass</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>执行结果如下：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$ ./smartptr tc01</span><br><span class="line">[StrongPointer.h:41] sp::sp(T*)</span><br><span class="line">[testlightptr.cpp:16] Light Ref Count: 1.</span><br><span class="line">[StrongPointer.h:47] sp::sp(const sp&lt;T&gt;&amp;)</span><br><span class="line">[testlightptr.cpp:19] Light Ref Count: 2.</span><br><span class="line">[StrongPointer.h:53] sp::~sp()</span><br><span class="line">[testlightptr.cpp:21] Light Ref Count:1.</span><br><span class="line">[StrongPointer.h:53] sp::~sp()</span><br></pre></td></tr></table></figure></p>
<h1 id="强-弱智能指针"><a href="#强-弱智能指针" class="headerlink" title="强/弱智能指针"></a>强/弱智能指针</h1><p>强/弱指针把我折腾的七荤八素的，因为没有原型可参考了，我相信这个设计必有出处，只是自己没有找到，于是只好啃代码。强/弱智能指针的代码比轻量级智能指针复杂很多，静态代码研究很容易陷入“每句代码都明白，就是抓不住灵魂”的境地，我发现最好的应对方法是从需求出发，找到一两个使用场景代入走查一下。好在这块代码比较独立，前面我已经把他们抽取出来，情景分析是比较容易的。</p>
<h2 id="强-弱智能指针的目的"><a href="#强-弱智能指针的目的" class="headerlink" title="强/弱智能指针的目的"></a>强/弱智能指针的目的</h2><p>轻量级智能指针可以完成对目标对象的引用计数的记录，并在没有没有任何指针指向目标对象的时候自动销毁对象，防止内存泄漏。但是当遇到循环引用的时候，该手段就失效了，如下图：<br><img src="img04.png" alt="当智能指针遇上循环引用"><br>当p不再指向objectA，其引用计数由2变为1，相互指向的objectA和objectB就变成悬浮的两座孤岛，再也没有路径可以访问到它们，于是造成了内存泄漏。</p>
<p>解决方案是给循环引用的双方定义主从关系，由主指向从的智能指针就称为强指针，由从指向主的指针就称为弱指针，强/弱指针仍然都是具备引用计数功能的智能指针，只是当一个对象没有强指针指向的时候就可以销毁掉了。如下图：<br><img src="img05.png" alt="强弱指针解决循环引用的问题"><br>实线代表强指针，虚线代表弱指针。当p不再指向objectA，其强引用计数递减为0，于是objectA可以销毁，它指向objectB的强指针也被销毁，于是objectB的强引用计数递减为0，objectB也可以销毁。</p>
<h2 id="强-弱智能指针的使用"><a href="#强-弱智能指针的使用" class="headerlink" title="强/弱智能指针的使用"></a>强/弱智能指针的使用</h2><p>强/弱智能指针的定义和使用形式如下：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 对象实体必须从RefBase派生，该类在`RefBase.h`和`RefBase.cpp`中声明和定义</span></span><br><span class="line"><span class="keyword">class</span> MyClass : <span class="keyword">public</span> RefBase</span><br><span class="line">&#123;</span><br><span class="line">......</span><br><span class="line">&#125;;</span><br><span class="line">......</span><br><span class="line">sp&lt;MyClass&gt; pStrong(new MyClass);   <span class="comment">// 定义强指针</span></span><br><span class="line">wp&lt;MyClass&gt; pWeak(new MyClass);     <span class="comment">// 定义弱指针</span></span><br></pre></td></tr></table></figure></p>
<p>我们来看看RefBase，frameworks/rs/cpp/util/RefBase.h<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> RefBase</span><br><span class="line">&#123;</span><br><span class="line">........</span><br><span class="line"></span><br><span class="line">    <span class="keyword">class</span> weakref_type</span><br><span class="line">    &#123;</span><br><span class="line">        ........</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">......</span><br><span class="line"></span><br><span class="line">    <span class="keyword">virtual</span>                 ~RefBase();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">enum</span> &#123;</span><br><span class="line">        OBJECT_LIFETIME_STRONG  = <span class="number">0x0000</span>,</span><br><span class="line">        OBJECT_LIFETIME_WEAK    = <span class="number">0x0001</span>,</span><br><span class="line">        OBJECT_LIFETIME_MASK    = <span class="number">0x0001</span></span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">......</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    ......</span><br><span class="line">    <span class="keyword">class</span> weakref_impl;</span><br><span class="line">        </span><br><span class="line">    weakref_impl* <span class="keyword">const</span> mRefs;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>和LightRefBase相比有三个明显的差异：</p>
<ol>
<li>没有模板参数，前文已经分析过LightRefBase使用模板参数是出于性能的考虑，省去一个虚表的开销，而RefBase定义了virtual的析构函数，可见继承关系可能是在所难免的，于是再用模板参数就没有任何意义了。</li>
<li>RefBase没有像LightRefBase那样直接用成员变量记录引用计数，而是又定义了一个weakref_impl<em>类型的成员，由它来记录强/弱引用计数。这是为什么？从前面模型图上就能找到答案：<br><img src="img05.png" alt="强弱指针解决循环引用的问题"><br>继续前面的推演，objectA被销毁后，objectB还有一个弱指针指向objectA的。objectA在销毁的时刻，只能处理由自己发出的指针，而无法知道都有谁指向了自己。于是objectA被销毁后，来自objectB的弱指针也就成了野指针。为了解决这个问题，可以让引用计数和对象实体分离，如下图：<br><img src="img06.png" alt="引用计数与对象实体分离"><br>于是就有了weakref_impl</em> mRefs成员，该成员被称为他所记录的实体对象的影子对象，影子和本尊之间有指针指向对方，但影子的生存周期可能比本尊还要长。因为影子负责记录本尊的强/弱引用计数，当强引用计数为0时，本尊被销毁，影子继续记录其弱引用计数，直到两个引用计数分别为0，影子才被销毁掉。</li>
<li>枚举类型OBJECT_LIFETIME_xxx。这本不算和LightRefBase之间的差异，但在阅读RefBase代码时这三种类型左右着实体对象的生命周期策略。这也是最让我疑惑的地方：既然强引用计数决定实体的生命周期，为什么还要在reakref_impl中用一个成员变量mFlags来记录实体的生命周期受哪个引用计数控制呢？试想如下这种情况：<br><img src="img07.png" alt=""><br>当p1不再指向objectA，它的强引用计数就为0了，于是可以被销毁。可此时还有p2指向objectB，两个实体对象并没有成为孤岛，还有可能要通过p2再访问objectA和objectB组成的循环链表，在objectA和objectB之间定义主从关系仅仅是为了避免孤岛导致的内存泄漏。所以尽管objectA此时的强引用计数已为0，只要弱引用计数还在，还是先留objectA一条小命，让它再苟延残喘一段时间，直到其弱引用计数也为0，说明彻底没用了，到那时候再真地干掉。这就是mFlags和这三个枚举类型的作用：<ul>
<li>当mFlags为OBJECT_LIFETIME_STRONG，实体对象的生命周期遵循强/弱指针最初始的规则：强引用计数为0，就销毁；</li>
<li>当mFlags为OBJECT_LIFETIME_WEAK，如果强引用计数为0，实体对象暂时不要销毁，等到弱引用计数也为0时再销毁</li>
</ul>
</li>
</ol>
<h2 id="情景分析-1"><a href="#情景分析-1" class="headerlink" title="情景分析"></a>情景分析</h2><h3 id="构造sp对象和wp对象"><a href="#构造sp对象和wp对象" class="headerlink" title="构造sp对象和wp对象"></a>构造sp对象和wp对象</h3><p>在smartptr.cpp中<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">tc03</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> <span class="keyword">const</span> *argv[])</span> <span class="comment">// 测试sp转为wp</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    return testSWPtr(argc, argv);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>testweightptr.cpp<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">testSWPtr</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> <span class="keyword">const</span> * argv[])</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    WeightClass* pObj = new WeightClass();  <span class="comment">// 创建RefBase对象实体</span></span><br><span class="line">    sp&lt;WeightClass&gt; spObj(pObj);            <span class="comment">// 用强指针指向该实体</span></span><br><span class="line">    spObj-&gt;printRefCount();</span><br><span class="line">    wp&lt;WeightClass&gt; wpObj(spObj);           <span class="comment">// 用弱指针指向强指针</span></span><br><span class="line">    spObj-&gt;printRefCount();</span><br><span class="line">    return <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="RefBase构造函数"><a href="#RefBase构造函数" class="headerlink" title="RefBase构造函数"></a>RefBase构造函数</h4><p>WeightClass继承自RefBase，其构造函数如下：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">RefBase::RefBase() </span><br><span class="line">    : mRefs(new weakref_impl(this))  <span class="comment">// RefBase对象在创建的同时会为自己创建影子对象</span></span><br><span class="line">&#123;</span><br><span class="line">    Logging(<span class="string">"RefBase::RefBase()"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>影子对象的构造如下：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">weakref_impl(RefBase* base) <span class="comment">// 初始化强弱引用计数，mBase指向本尊完成互指</span></span><br><span class="line">    : mStrong(INITIAL_STRONG_VALUE)</span><br><span class="line">    , mWeak(<span class="number">0</span>)</span><br><span class="line">    , mBase(base)</span><br><span class="line">    , mFlags(<span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">    Logging(<span class="string">"RefBase::weakref_impl::weakref_impl(RefBase* base)"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><strong> 因此，构造一个RefBase对象完成的工作就是，创建负责维护引用计数的影子对象，初始化强弱引用计数，并完成本尊和影子的互指。</strong></p>
<h4 id="sp拷贝构造函数"><a href="#sp拷贝构造函数" class="headerlink" title="sp拷贝构造函数"></a>sp拷贝构造函数</h4><p>回到<code>testSWPtr(...)</code>函数，接下来的<code>sp&lt;WeightClass&gt; spObj(pObj);</code>执行sp的拷贝构造函数：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">sp(T* other): m_ptr(other)</span><br><span class="line">&#123;</span><br><span class="line">    Logging(<span class="string">"sp::sp(T*)"</span>);</span><br><span class="line">    <span class="keyword">if</span> (other) other-&gt;incStrong(<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>它会增加实体对象的强引用计数，即RefBase::incStrong(…)。RefBase.cpp:<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> RefBase::incStrong(<span class="keyword">const</span> <span class="keyword">void</span>* id) <span class="keyword">const</span></span><br><span class="line">&#123;</span><br><span class="line">    weakref_impl* <span class="keyword">const</span> refs = mRefs;</span><br><span class="line">    refs-&gt;incWeak(id);  <span class="comment">// 累加弱引用计数</span></span><br><span class="line">    </span><br><span class="line">    refs-&gt;addStrongRef(id); <span class="comment">// 忽略</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int32_t</span> c = android_atomic_inc(&amp;refs-&gt;mStrong);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (c != INITIAL_STRONG_VALUE)  &#123;</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    android_atomic_add(-INITIAL_STRONG_VALUE, &amp;refs-&gt;mStrong);</span><br><span class="line">    refs-&gt;mBase-&gt;onFirstRef();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>weakref_impl的定义在RefBase.cpp中，其中有一堆空函数，在Debug版本中用于调试，因此遇到这样的代码都可以忽略：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addStrongRef</span><span class="params">(<span class="keyword">const</span> <span class="keyword">void</span>* <span class="comment">/*id*/</span>)</span> </span>&#123; &#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">removeStrongRef</span><span class="params">(<span class="keyword">const</span> <span class="keyword">void</span>* <span class="comment">/*id*/</span>)</span> </span>&#123; &#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">renameStrongRefId</span><span class="params">(<span class="keyword">const</span> <span class="keyword">void</span>* <span class="comment">/*old_id*/</span>, <span class="keyword">const</span> <span class="keyword">void</span>* <span class="comment">/*new_id*/</span>)</span> </span>&#123; &#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addWeakRef</span><span class="params">(<span class="keyword">const</span> <span class="keyword">void</span>* <span class="comment">/*id*/</span>)</span> </span>&#123; &#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">removeWeakRef</span><span class="params">(<span class="keyword">const</span> <span class="keyword">void</span>* <span class="comment">/*id*/</span>)</span> </span>&#123; &#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">renameWeakRefId</span><span class="params">(<span class="keyword">const</span> <span class="keyword">void</span>* <span class="comment">/*old_id*/</span>, <span class="keyword">const</span> <span class="keyword">void</span>* <span class="comment">/*new_id*/</span>)</span> </span>&#123; &#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printRefs</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; &#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">trackMe</span><span class="params">(<span class="keyword">bool</span>, <span class="keyword">bool</span>)</span> </span>&#123; &#125;</span><br></pre></td></tr></table></figure></p>
<p><code>RefBase::inStrong(...)</code>函数主要干了三件事：</p>
<ol>
<li><p>累加弱引用计数，其调用很简单</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> RefBase::weakref_type::incWeak(<span class="keyword">const</span> <span class="keyword">void</span>* id)</span><br><span class="line">&#123;</span><br><span class="line">    weakref_impl* <span class="keyword">const</span> impl = <span class="keyword">static_cast</span>&lt;weakref_impl*&gt;(this);</span><br><span class="line">    impl-&gt;addWeakRef(id); <span class="comment">// 忽略</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int32_t</span> c __unused = android_atomic_inc(&amp;impl-&gt;mWeak);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>累加强引用计数。<br>强引用计数在构造的时候被初始化为INITIAL_STRONG_VALUE，表示“我是处”！这是个不可能达到的极大常量，第一次累加后会把该常量减掉</p>
</li>
<li>如果强引用计数破处，通知本尊，允许它在第一次时做一些和业务逻辑相关的事情</li>
</ol>
<p>问题来了：明明是incStrong(…)，增加强引用计数，为什么连带弱引用计数一起加呢？谁能告诉我答案？<br>我的猜测是酱紫滴：主要出于简化逻辑的考虑，前文分析过一般情况下，当强引用计数递减到0就可以销毁实体对象了，此时影子还不能销毁，因为还要维护弱引用计数，直到弱引用计数递减到0才可以销毁影子对象。也就是说：</p>
<blockquote>
<p>强引用计数控制实体对象的生命周期，弱引用计数控制影子对象的生命周期。</p>
</blockquote>
<p>这句话的描述显然比上一段简洁，转换成代码也是一样的，两个对象的销毁只看单一变量就可以了，由此带来的代价就是要在强引用计数累加的同时也要累加弱引用计数。你可能会觉得根据两个变量决定影子的销毁策略并没有引入太大的复杂度，可是还有第三个变量mFlags，纠缠在一起事情就变得麻烦很多，后面我们就会遇到。我认为这个deal是非常划算的。</p>
<p><strong> 因此sp的拷贝构造函数完成的工作是：初始化实体对象指针，将实体对象的强弱引用计数加1，并允许其第一次被强引用时插入业务逻辑 </strong></p>
<h4 id="wp拷贝构造函数"><a href="#wp拷贝构造函数" class="headerlink" title="wp拷贝构造函数"></a>wp拷贝构造函数</h4><p>回到<code>testSWPtr(...)</code>函数，接下来的<code>wp&lt;WeightClass&gt; wpObj(spObj);</code>执行wp拷贝构造函数：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">wp&lt;T&gt;::wp(<span class="keyword">const</span> sp&lt;T&gt;&amp; other)</span><br><span class="line">    : m_ptr(other.m_ptr)</span><br><span class="line">&#123;</span><br><span class="line">    Logging(<span class="string">"wp::wp(const sp&lt;T&gt;&amp; other)"</span>);</span><br><span class="line">    <span class="keyword">if</span> (m_ptr) &#123;</span><br><span class="line">        m_refs = m_ptr-&gt;createWeak(this);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>执行了实体对象即RefBase的createWeak(…)函数：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">RefBase::weakref_type* RefBase::createWeak(<span class="keyword">const</span> <span class="keyword">void</span>* id) <span class="keyword">const</span></span><br><span class="line">&#123;</span><br><span class="line">    mRefs-&gt;incWeak(id); <span class="comment">// 前面遇到过这行代码，就是将弱引用计数累加1</span></span><br><span class="line">    return mRefs;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><strong> wp的拷贝构造函数很简单，就是将实体对象的弱引用计数累加1，然后把实体对象的影子交给自己的m_refs成员。 </strong><br>我们来比较一下sp和wp的数据成员，sp只有一个m_ptr，代表它所指向的实体对象，而wp有两个：m_ptr和m_refs。前者是它所指向的实体对象，后者是该实体对象的影子对象。前面说过，本尊和影子之间是互指的，得到一个就能找到另一个，但是本尊可能比影子更早地被销毁掉，因此弱指针wp仅保存m_ptr是不够的，必须同时保存其影子；而强指针则不必，因为强引用计数递减到0，m_ptr被销毁，强指针也就没有存在的意义了。</p>
<p>构造部分就分析完了，隐藏的析构部分。</p>
<h4 id="wp析构函数"><a href="#wp析构函数" class="headerlink" title="wp析构函数"></a>wp析构函数</h4><p>首先被析构的是wp，RefBase.h<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">wp&lt;T&gt;::~wp()</span><br><span class="line">&#123;</span><br><span class="line">    Logging(<span class="string">"wp::~wp()"</span>);</span><br><span class="line">    <span class="keyword">if</span> (m_ptr) m_refs-&gt;decWeak(<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>继续追踪RefBase.cpp<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> RefBase::weakref_type::decWeak(<span class="keyword">const</span> <span class="keyword">void</span>* id)</span><br><span class="line">&#123;</span><br><span class="line">    weakref_impl* <span class="keyword">const</span> impl = <span class="keyword">static_cast</span>&lt;weakref_impl*&gt;(this);</span><br><span class="line">    impl-&gt;removeWeakRef(id);  <span class="comment">// 忽略</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int32_t</span> c = android_atomic_dec(&amp;impl-&gt;mWeak); <span class="comment">// 递减弱引用计数</span></span><br><span class="line">    <span class="keyword">if</span> (c != <span class="number">1</span>) return;</span><br><span class="line">    <span class="comment">// 如果弱引用计数被减到0</span></span><br><span class="line">    <span class="keyword">if</span> ((impl-&gt;mFlags&amp;OBJECT_LIFETIME_WEAK) == OBJECT_LIFETIME_STRONG) &#123;</span><br><span class="line">                <span class="comment">// 一般逻辑</span></span><br><span class="line">        <span class="comment">// This is the regular lifetime case. The object is destroyed</span></span><br><span class="line">        <span class="comment">// when the last strong reference goes away. Since weakref_impl</span></span><br><span class="line">        <span class="comment">// outlive the object, it is not destroyed in the dtor, and</span></span><br><span class="line">        <span class="comment">// we'll have to do it here.</span></span><br><span class="line">        <span class="keyword">if</span> (impl-&gt;mStrong == INITIAL_STRONG_VALUE) &#123;</span><br><span class="line">            <span class="comment">// Special case: we never had a strong reference, so we need to</span></span><br><span class="line">            <span class="comment">// destroy the object now.</span></span><br><span class="line">            <span class="keyword">delete</span> impl-&gt;mBase;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// ALOGV("Freeing refs %p of old RefBase %p\n", this, impl-&gt;mBase);</span></span><br><span class="line">            <span class="keyword">delete</span> impl;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;    <span class="comment">// 暂存逻辑</span></span><br><span class="line">        <span class="comment">// less common case: lifetime is OBJECT_LIFETIME_&#123;WEAK|FOREVER&#125;</span></span><br><span class="line">        impl-&gt;mBase-&gt;onLastWeakRef(id);</span><br><span class="line">        <span class="keyword">if</span> ((impl-&gt;mFlags&amp;OBJECT_LIFETIME_MASK) == OBJECT_LIFETIME_WEAK) &#123;</span><br><span class="line">            <span class="comment">// this is the OBJECT_LIFETIME_WEAK case. The last weak-reference</span></span><br><span class="line">            <span class="comment">// is gone, we can destroy the object.</span></span><br><span class="line">            <span class="keyword">delete</span> impl-&gt;mBase;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>如果弱引用计数被递减到0，就需要根据mFlags来分别处理了，不记得OBJECT_LIFETIME_xxx的点右侧的火箭上楼复习:)</p>
<ul>
<li>mFlags为OBJECT_LIFETIME_STRONG就是一般逻辑，即强引用计数减到0时立即销毁实体对象。弱引用计数被递减到0也就意味着强引用计数也必为0，不过这个0有两种可能：1、强引用计数从未被破处过，即<code>impl-&gt;mStrong == INITIAL_STRONG_VALUE</code>为真，此时需要销毁掉实体对象；2、强引用计数被递减到了0，那么实体对象此时肯定已经不存在了（因为在强引用计数被递减到0的时刻已经被销毁了），此时只需要销毁影子对象。</li>
<li><code>(impl-&gt;mFlags&amp;OBJECT_LIFETIME_WEAK) == OBJECT_LIFETIME_STRONG</code>非真则是缓存逻辑，即实体对象会被缓存直到弱引用计数也递减到0才销毁。与onFirstRef()类似，在被销毁掉之前有机会让实体对象执行一把业务逻辑onLastWeakRef(…)，然后销毁实体对象。我认为这里面的if语句是多余了，它有非真的可能吗？</li>
</ul>
<p>有一个问题：此处为什么有销毁实体对象的逻辑分支，就不再销毁影子对象impl了，而没有销毁实体对象的分支需要销毁影子对象呢？这不会造成影子对象的泄露吗？</p>
<p>答案隐藏在实体对象RefBase的析构函数中，RefBase.cpp：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">RefBase::~RefBase()</span><br><span class="line">&#123;</span><br><span class="line">    Logging(<span class="string">"RefBase::~RefBase()"</span>);</span><br><span class="line">    <span class="keyword">if</span> (mRefs-&gt;mStrong == INITIAL_STRONG_VALUE) &#123;</span><br><span class="line">        <span class="comment">// we never acquired a strong (and/or weak) reference on this object.</span></span><br><span class="line">        <span class="keyword">delete</span> mRefs;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 暂存逻辑</span></span><br><span class="line">        <span class="comment">// life-time of this object is extended to WEAK or FOREVER, in</span></span><br><span class="line">        <span class="comment">// which case weakref_impl doesn't out-live the object and we</span></span><br><span class="line">        <span class="comment">// can free it now.</span></span><br><span class="line">        <span class="keyword">if</span> ((mRefs-&gt;mFlags &amp; OBJECT_LIFETIME_MASK) != OBJECT_LIFETIME_STRONG) &#123;</span><br><span class="line">            <span class="comment">// It's possible that the weak count is not 0 if the object</span></span><br><span class="line">            <span class="comment">// re-acquired a weak reference in its destructor</span></span><br><span class="line">            <span class="keyword">if</span> (mRefs-&gt;mWeak == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">delete</span> mRefs;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// for debugging purposes, clear this.</span></span><br><span class="line">    <span class="keyword">const_cast</span>&lt;weakref_impl*&amp;&gt;(mRefs) = <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>该析构函数主要就是负责销毁影子对象：</p>
<ul>
<li>当实体对象从未被强指针指向过，那只有两种可能：<ul>
<li>未被弱指针指向过，也就是说跟智能指针没关系了，它在构造的时候创建了影子对象，析构时当然要负责销毁</li>
<li>被弱指针指向过，此时的析构必然是因为弱引用计数递减到了0而导致，decWeak(…)没有负责销毁影子对象，因此这里就必须要做</li>
</ul>
</li>
<li>或者在暂存逻辑下弱引用计数为0，则销毁影子对象。</li>
</ul>
<p>回到前面的<code>void RefBase::weakref_type::decWeak(const void* id)</code>，<br>当弱引用计数被递减到0：</p>
<ul>
<li>在一般逻辑下<ul>
<li>如果强引用计数未被破处：则销毁实体对象，对象的析构函数又会销毁影子对象</li>
<li>否则也就意味着强引用计数被递减到了0，当时实体对象就被销毁了，但弱引用计数不为0，所以对象的析构函数不会销毁影子，此时需要把影子销毁掉</li>
</ul>
</li>
<li>在暂存逻辑下，让实体对象说几句遗言，然后销毁之，对象的析构函数又会销毁掉影子对象</li>
</ul>
<p>可以看出销毁影子对象的职责优先由RefBase的析构函数来做，这也是合情合理的，因为影子对象是由RefBase的构造函数创建出来的。仅当RefBase析构函数无法完成销毁影子对象的时候，即RefBase先于影子销毁的时候，才交给decWeak(…)函数在弱引用计数递减到0的时候完成销毁。</p>
<p>以上是wp析构函数的完整分析，不过结合tc03实例，wp析构的时候，实体对象的弱引用计数并为递减到0，因此<code>void RefBase::weakref_type::decWeak(const void* id)</code>仅仅将其弱引用计数递减到1，在第#6行就返回了。接下来则是sp的析构。</p>
<h4 id="sp析构函数"><a href="#sp析构函数" class="headerlink" title="sp析构函数"></a>sp析构函数</h4><p>StrongPointer.h:<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">~sp()</span><br><span class="line">&#123;</span><br><span class="line">    Logging(<span class="string">"sp::~sp()"</span>);</span><br><span class="line">    <span class="keyword">if</span> (m_ptr) m_ptr-&gt;decStrong(<span class="keyword">this</span>); <span class="comment">// 递减强引用计数</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>继续追踪RefBase.cpp:<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> RefBase::decStrong(<span class="keyword">const</span> <span class="keyword">void</span>* id) <span class="keyword">const</span></span><br><span class="line">&#123;</span><br><span class="line">    weakref_impl* <span class="keyword">const</span> refs = mRefs;</span><br><span class="line">    refs-&gt;removeStrongRef(id);  <span class="comment">// 忽略</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int32_t</span> c = android_atomic_dec(&amp;refs-&gt;mStrong);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (c == <span class="number">1</span>) &#123;</span><br><span class="line">        refs-&gt;mBase-&gt;onLastStrongRef(id);</span><br><span class="line">        <span class="comment">// 一般逻辑</span></span><br><span class="line">        <span class="keyword">if</span> ((refs-&gt;mFlags&amp;OBJECT_LIFETIME_MASK) == OBJECT_LIFETIME_STRONG) &#123;</span><br><span class="line">            <span class="keyword">delete</span> <span class="keyword">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    refs-&gt;decWeak(id);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><code>decStrong(...)</code>主要完成两件事：</p>
<ul>
<li>递减强引用计数，如果是一般逻辑，当强引用计数减到0则销毁实体对象</li>
<li>递减弱引用计数，如果弱引用计数也递减到0，也会引发一堆销毁处理，前文已经分析过了<br>结合本例，到此时强弱引用计数才被递减到0，在decWeak(…)中才执行影子对象的销毁。</li>
</ul>
<p>下面是tc03的执行结果：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">$ ./smartptr tc03</span><br><span class="line">[RefBase.cpp:25] RefBase::weakref_impl::weakref_impl(RefBase* base)</span><br><span class="line">[RefBase.cpp:315] RefBase::RefBase()</span><br><span class="line">[StrongPointer.h:41] sp::sp(T*)</span><br><span class="line">[StrongPointer.h:73] sp::operator-&gt;()</span><br><span class="line">[testweightptr.cpp:17] StrongCount=1. WeakCount=1.</span><br><span class="line">[RefBase.h:274] wp::wp(const sp&lt;T&gt;&amp; other)</span><br><span class="line">[StrongPointer.h:73] sp::operator-&gt;()</span><br><span class="line">[testweightptr.cpp:17] StrongCount=1. WeakCount=2.</span><br><span class="line">[RefBase.h:312] wp::~wp()</span><br><span class="line">[StrongPointer.h:53] sp::~sp()</span><br><span class="line">[RefBase.cpp:320] RefBase::~RefBase()</span><br></pre></td></tr></table></figure></p>
<p>尽管只分析了一个用例，我觉得已经把Android的智能指针研究得很透彻了，也揭开了之前看binder代码的一些疑团。如果本周还有时间，我会再分析一下弱指针由弱升强的<code>wp::promte()</code>函数，其实也不过是前面获得的认知的综合运用而已，没有太新鲜的内容。</p>
<p>苦苦追寻了一个礼拜，今晚终于可以睡个踏实觉啦。<br>最后再沉淀几句鸡汤：读代码不要一头扎得太深，初期观其大略了解意图最重要，这也是说起来容易，如果代码量大一些，把“大略”装到肚子里也挺考验肺活量，尤其是上班累得像狗一样，只能每晚一两个小时来搞。把当天研究的内容记录下来，做有效的沉淀很重要，我用hexo的draft来暂存。最后，尽量扩展自己的视野，讲究的程序员是最懂得不重复造轮子的，一来成熟的东西稳定；二来模式降低了学习和交流沟通的成本。</p>
</div><script type="text/javascript" src="/blog/js/share.js?v=0.0.0" async></script><a data-url="http://palanceli.github.io/blog/2016/06/10/2016/0610BinderLearning11/" data-id="cipctsop70000gczik2c8dzu5" class="article-share-link">分享到</a><div class="tags"><a href="/blog/tags/binder/">binder</a></div><div class="post-nav"><a href="/blog/2016/05/28/2016/0528BinderLearning10/" class="next">binder学习笔记（十）—— 穿越到驱动层</a></div><div id="disqus_thread"><script>var disqus_shortname = 'palance';
var disqus_identifier = '2016/06/10/2016/0610BinderLearning11/';
var disqus_title = 'Binder学习笔记（十）—— 智能指针';
var disqus_url = 'http://palanceli.github.io/2016/06/10/2016/0610BinderLearning11/';
(function() {
  var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
  dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
  (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
})();</script><script id="dsq-count-scr" src="//palance.disqus.com/count.js" async></script></div></div></div></div><div class="pure-u-1-4"><div id="sidebar"><div class="widget"><div class="widget-title"><i class="fa fa-folder-o"> 分类</i></div><ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/blog/categories/Android/">Android</a></li><li class="category-list-item"><a class="category-list-link" href="/blog/categories/环境、配置/">环境、配置</a></li><li class="category-list-item"><a class="category-list-link" href="/blog/categories/生活/">生活</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-star-o"> 标签</i></div><div class="tagcloud"><a href="/blog/tags/binder/" style="font-size: 15px;">binder</a> <a href="/blog/tags/hexo/" style="font-size: 15px;">hexo</a> <a href="/blog/tags/音乐/" style="font-size: 15px;">音乐</a></div></div><div class="widget"><div class="widget-title"><i class="fa fa-file-o"> 最新文章</i></div><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/blog/2016/06/10/2016/0610BinderLearning11/">Binder学习笔记（十）—— 智能指针</a></li><li class="post-list-item"><a class="post-list-link" href="/blog/2016/05/28/2016/0528BinderLearning10/">binder学习笔记（十）—— 穿越到驱动层</a></li><li class="post-list-item"><a class="post-list-link" href="/blog/2016/05/21/2016/0521小雨点参加钢琴比赛/">小雨点第一次参加钢琴比赛</a></li><li class="post-list-item"><a class="post-list-link" href="/blog/2016/05/15/2016/0514BinderLearning9/">Binder学习笔记（九）—— 服务端如何响应Test()请求 ？ </a></li><li class="post-list-item"><a class="post-list-link" href="/blog/2016/05/14/2016/0514BinderLearning8/">Binder学习笔记（八）—— 客户端如何组织Test()请求 ？ </a></li><li class="post-list-item"><a class="post-list-link" href="/blog/2016/05/12/2016/0512使用hexo搭建博客并上传GitHub/">使用hexo搭建博客并上传GitHub</a></li><li class="post-list-item"><a class="post-list-link" href="/blog/2016/05/12/2016/0514BinderLearning7/">Binder学习笔记（七）—— ServiceManager如何响应addService请求 ？ </a></li><li class="post-list-item"><a class="post-list-link" href="/blog/2016/05/11/2016/0514BinderLearning6/">Binder学习笔记（六）—— binder服务端是如何组织addService数据的？ </a></li><li class="post-list-item"><a class="post-list-link" href="/blog/2016/05/10/2016/0514BinderLearning5/">Binder学习笔记（五）—— Parcel是怎么打包的？ </a></li><li class="post-list-item"><a class="post-list-link" href="/blog/2016/05/09/2016/0514BinderLearning4/">Binder学习笔记（四）—— ServiceManager如何响应checkService请求 </a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-comment-o"> 最近评论</i></div><script type="text/javascript" src="//palance.disqus.com/recent_comments_widget.js?num_items=5&amp;hide_avatars=1&amp;avatar_size=32&amp;excerpt_length=20&amp;hide_mods=1"></script></div><div class="widget"><div class="widget-title"><i class="fa fa-external-link"> 友情链接</i></div><ul></ul><a href="https://github.com/palanceli" title="我的GitHub" target="_blank">我的GitHub</a><ul></ul><a href="http://www.cnblogs.com/palance/" title="我的博客园" target="_blank">我的博客园</a><ul></ul><a href="http://blog.csdn.net/zchongr" title="我的CSDN" target="_blank">我的CSDN</a><ul></ul><a href="http://www.jianshu.com/users/5e527164a8c2" title="我的简书" target="_blank">我的简书</a></div></div></div><div class="pure-u-1 pure-u-md-3-4"><div id="footer">© <a href="/blog/." rel="nofollow">Palance's Blog.</a> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a><a rel="nofollow" target="_blank" href="https://github.com/tufu9441/maupassant-hexo"> Theme</a> by<a rel="nofollow" target="_blank" href="https://github.com/pagecho"> Cho.</a></div></div></div><a id="rocket" href="#top" class="show"></a><script type="text/javascript" src="/blog/js/totop.js?v=0.0.0" async></script><script type="text/javascript" src="//cdn.bootcss.com/fancybox/2.1.5/jquery.fancybox.pack.js" async></script><script type="text/javascript" src="/blog/js/fancybox.js?v=0.0.0" async></script><link rel="stylesheet" type="text/css" href="/blog/css/jquery.fancybox.css?v=0.0.0"><script type="text/javascript" src="/blog/js/codeblock-resizer.js?v=0.0.0"></script><script type="text/javascript" src="/blog/js/smartresize.js?v=0.0.0"></script></div></body></html>